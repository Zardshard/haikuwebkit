diff --git a/scripts/export_targets.py b/scripts/export_targets.py
index 309d405..8de997c 100755
--- a/scripts/export_targets.py
+++ b/scripts/export_targets.py
@@ -231,9 +231,9 @@ IGNORED_INCLUDES = {
     b'vulkan_xcb.h',
     b'vulkan_xlib.h',
     b'vulkan_xlib_xrandr.h',
-# rapidjson adds these include stubs into their documentation
-# comments. Since the script doesn't skip comments they are
-# erroneously marked as valid includes
+    # rapidjson adds these include stubs into their documentation
+    # comments. Since the script doesn't skip comments they are
+    # erroneously marked as valid includes
     b'rapidjson/...',
     # Validation layers support building with robin hood hashing, but we are not enabling that
     # See http://anglebug.com/5791
diff --git a/scripts/run_code_generation.py b/scripts/run_code_generation.py
index 9710b2e..c0a9a13 100755
--- a/scripts/run_code_generation.py
+++ b/scripts/run_code_generation.py
@@ -13,6 +13,7 @@ import os
 import subprocess
 import sys
 import platform
+import argparse
 
 script_dir = sys.path[0]
 root_dir = os.path.abspath(os.path.join(script_dir, '..'))
@@ -214,11 +215,31 @@ def main():
     all_new_hashes = {}
     any_dirty = False
 
-    verify_only = False
-    if len(sys.argv) > 1 and sys.argv[1] == '--verify-no-dirty':
-        verify_only = True
+    parser = argparse.ArgumentParser(description='Generate ANGLE internal code.')
+    parser.add_argument(
+        '-v',
+        '--verify-no-dirty',
+        dest='verify_only',
+        type=bool,
+        help='verify hashes are not dirty')
+    parser.add_argument(
+        '-g', '--generator', action='append', nargs='*', type=str, dest='specifiedGenerators'),
+
+    args = parser.parse_args()
+    filteredGenerators = args.specifiedGenerators[0]
+    verify_only = args.verify_only
+    ranGenerators = {}
+
+    if (filteredGenerators):
+        ranGenerators = {k: v for k, v in generators.items() if k in filteredGenerators}
+    else:
+        ranGenerators = generators
+
+    if (len(ranGenerators) == 0):
+        print("No valid generators specified.")
+        return -1
 
-    for name, script in sorted(generators.items()):
+    for name, script in sorted(ranGenerators.items()):
         info = auto_script(script)
         fname = get_hash_file_name(name)
         filenames = info['inputs'] + info['outputs'] + [script]
@@ -257,7 +278,7 @@ def main():
             sys.exit(1)
 
         # Update the output hashes again since they can be formatted.
-        for name, script in sorted(generators.items()):
+        for name, script in sorted(ranGenerators.items()):
             info = auto_script(script)
             fname = get_hash_file_name(name)
             update_output_hashes(name, info['outputs'], all_new_hashes[fname])
diff --git a/src/common/utilities.cpp b/src/common/utilities.cpp
index bf15015..f077059 100644
--- a/src/common/utilities.cpp
+++ b/src/common/utilities.cpp
@@ -6,6 +6,12 @@
 
 // utilities.cpp: Conversion functions and other utility routines.
 
+// Older clang versions have a false positive on this warning here.
+// TODO(dino): Is this still necessary?
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+#endif
+
 #include "common/utilities.h"
 #include "GLES3/gl3.h"
 #include "common/mathutil.h"
diff --git a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
index 4711774..cf25e48 100644
--- a/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
+++ b/src/compiler/preprocessor/preprocessor_tab_autogen.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/CodeGen.cpp b/src/compiler/translator/CodeGen.cpp
index 497ef88..47213c9 100644
--- a/src/compiler/translator/CodeGen.cpp
+++ b/src/compiler/translator/CodeGen.cpp
@@ -23,6 +23,9 @@
 #ifdef ANGLE_ENABLE_METAL
 #    include "compiler/translator/TranslatorMetalDirect.h"
 #endif  // ANGLE_ENABLE_METAL
+#ifdef ANGLE_ENABLE_METAL_SPIRV
+#    include "compiler/translator/TranslatorMetal.h"
+#endif  // ANGLE_ENABLE_METAL_SPIRV
 
 #ifdef ANGLE_ENABLE_METAL_SPIRV
 #    include "compiler/translator/TranslatorMetal.h"
diff --git a/src/compiler/translator/TranslatorMetal.cpp b/src/compiler/translator/TranslatorMetal.cpp
index 7ac4749..d25b72a 100644
--- a/src/compiler/translator/TranslatorMetal.cpp
+++ b/src/compiler/translator/TranslatorMetal.cpp
@@ -32,13 +32,6 @@
 namespace sh
 {
 
-namespace mtl
-{
-/** extern */
-const char kCoverageMaskEnabledConstName[]      = "ANGLECoverageMaskEnabled";
-const char kRasterizerDiscardEnabledConstName[] = "ANGLERasterizerDisabled";
-}  // namespace mtl
-
 namespace
 {
 
diff --git a/src/compiler/translator/TranslatorMetalConstantNames.cpp b/src/compiler/translator/TranslatorMetalConstantNames.cpp
new file mode 100644
index 0000000..515cc6e
--- /dev/null
+++ b/src/compiler/translator/TranslatorMetalConstantNames.cpp
@@ -0,0 +1,24 @@
+//
+// Copyright 2019 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// TranslatorMetalConstantNames:
+// Implementation of constant values used in both translator
+// backends.
+
+#include <stdio.h>
+
+#include "GLSLANG/ShaderLang.h"
+
+namespace sh
+{
+
+namespace mtl
+{
+/** extern */
+const char kCoverageMaskEnabledConstName[]      = "ANGLECoverageMaskEnabled";
+const char kRasterizerDiscardEnabledConstName[] = "ANGLERasterizerDisabled";
+}  // namespace mtl
+
+}  // namespace sh
diff --git a/src/compiler/translator/TranslatorMetalDirect.cpp b/src/compiler/translator/TranslatorMetalDirect.cpp
index 62cd1bf..3eaf905 100644
--- a/src/compiler/translator/TranslatorMetalDirect.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect.cpp
@@ -959,7 +959,6 @@ bool TranslatorMetalDirect::translateImpl(TInfoSinkBase &sink,
                 getSymbolTable().findBuiltIn(ImmutableString("gl_PointSize"), getShaderVersion()));
             DeclareRightBeforeMain(*root, *pointSize);
         }
-
         if (FindSymbolNode(root, BuiltInVariable::gl_VertexIndex()->name()))
         {
             if (!ReplaceVariable(this, root, BuiltInVariable::gl_VertexIndex(), &kgl_VertexIDMetal))
diff --git a/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp b/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
index e13d6e7..f9bb4e9 100644
--- a/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/EmitMetal.cpp
@@ -1738,7 +1738,6 @@ void GenMetalTraverser::emitFunctionSignature(const TFunction &func)
         const TVariable &param = *func.getParam(i);
         emitFunctionParameter(func, param);
     }
-
     if (isTraversingVertexMain)
     {
         mOut << " @@XFB-Bindings@@ ";
diff --git a/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h b/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h
new file mode 100644
index 0000000..d823fc7
--- /dev/null
+++ b/src/compiler/translator/TranslatorMetalDirect/EnvironmentVariable.h
@@ -0,0 +1,45 @@
+//
+// Copyright 2020 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+#ifndef COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
+#define COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
+
+#include <cstdlib>
+#include <string>
+
+#include "common/debug.h"
+
+namespace sh
+{
+
+inline bool readBoolEnvVar(const char *var)
+{
+    const char *str = std::getenv(var);
+    if (str == nullptr)
+    {
+        return false;
+    }
+    if (strcmp(str, "0") == 0)
+    {
+        return false;
+    }
+    ASSERT(strcmp(str, "1") == 0);
+    return true;
+}
+
+inline std::string readStringEnvVar(const char *var)
+{
+    const char *str = std::getenv(var);
+    if (str == nullptr)
+    {
+        return "";
+    }
+    return str;
+}
+
+}  // namespace sh
+
+#endif  // COMPILER_TRANSLATOR_TRANSLATORMETALDIRECT_ENVIRONMENTVARIABLE_H_
diff --git a/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp b/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
index 81ff272..9d2b43b 100644
--- a/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/IdGen.cpp
@@ -25,7 +25,7 @@ Name IdGen::createNewName(size_t count,
 {
     const unsigned id = mNext++;
     char idBuffer[std::numeric_limits<unsigned>::digits10 + 1];
-    sprintf(idBuffer, "%u", id);
+    snprintf(idBuffer, sizeof(idBuffer), "%u", id);
 
     mNewNameBuffer.clear();
     mNewNameBuffer += '_';
diff --git a/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp b/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
index 7fe13a6..299a2f9 100644
--- a/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/ModifyStruct.cpp
@@ -601,7 +601,7 @@ class ConvertStructState : angle::NonCopyable
     void pushNamePath(unsigned extra)
     {
         char buffer[std::numeric_limits<unsigned>::digits10 + 1];
-        sprintf(buffer, "%u", extra);
+        snprintf(buffer, sizeof(buffer), "%u", extra);
         pushNamePath(buffer);
     }
 
diff --git a/src/compiler/translator/TranslatorMetalDirect/ProgramPrelude.cpp b/src/compiler/translator/TranslatorMetalDirect/ProgramPrelude.cpp
index 813149b..1084e4a 100644
--- a/src/compiler/translator/TranslatorMetalDirect/ProgramPrelude.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/ProgramPrelude.cpp
@@ -1095,6 +1095,8 @@ ANGLE_ALWAYS_INLINE bool ANGLE_equalStructArray(metal::array<T, N> u, metal::arr
 }
 )")
 
+
+
 PROGRAM_PRELUDE_DECLARE(notEqualArray,
                         R"(
 template <typename T, size_t N>
@@ -3605,7 +3607,7 @@ void ProgramPrelude::visitOperator(TOperator op,
             break;
             
         case TOperator::EOpSubAssign:
-            if (argType0->isMatrix() && argType1->isScalar())
+            if(argType0->isMatrix() && argType1->isScalar())
             {
                 subMatrixScalarAssign();
             }
diff --git a/src/compiler/translator/TranslatorMetalDirect/ReduceInterfaceBlocks.cpp b/src/compiler/translator/TranslatorMetalDirect/ReduceInterfaceBlocks.cpp
index 45053e2..25f3d5e 100644
--- a/src/compiler/translator/TranslatorMetalDirect/ReduceInterfaceBlocks.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/ReduceInterfaceBlocks.cpp
@@ -21,6 +21,7 @@ using namespace sh;
 namespace
 {
 
+
 class Reducer : public TIntermRebuild
 {
     std::unordered_map<const TInterfaceBlock *, const TVariable *> mLiftedMap;
diff --git a/src/compiler/translator/TranslatorMetalDirect/SymbolEnv.cpp b/src/compiler/translator/TranslatorMetalDirect/SymbolEnv.cpp
index 85609e8..b255727 100644
--- a/src/compiler/translator/TranslatorMetalDirect/SymbolEnv.cpp
+++ b/src/compiler/translator/TranslatorMetalDirect/SymbolEnv.cpp
@@ -218,12 +218,12 @@ Name SymbolEnv::TemplateName::fullName(std::string &buffer) const
                     break;
 
                 case TemplateArg::Kind::Int:
-                    sprintf(argBuffer, "%i", value.i);
+                    snprintf(argBuffer, sizeof(argBuffer), "%i", value.i);
                     buffer += argBuffer;
                     break;
 
                 case TemplateArg::Kind::UInt:
-                    sprintf(argBuffer, "%u", value.u);
+                    snprintf(argBuffer, sizeof(argBuffer), "%u", value.u);
                     buffer += argBuffer;
                     break;
 
@@ -240,15 +240,15 @@ Name SymbolEnv::TemplateName::fullName(std::string &buffer) const
                         buffer += type.getBasicString();
                         if (type.isVector())
                         {
-                            sprintf(argBuffer, "%i", type.getNominalSize());
+                            snprintf(argBuffer, sizeof(argBuffer), "%i", type.getNominalSize());
                             buffer += argBuffer;
                         }
                         else if (type.isMatrix())
                         {
-                            sprintf(argBuffer, "%i", type.getCols());
+                            snprintf(argBuffer, sizeof(argBuffer), "%i", type.getCols());
                             buffer += argBuffer;
                             buffer += "x";
-                            sprintf(argBuffer, "%i", type.getRows());
+                            snprintf(argBuffer, sizeof(argBuffer), "%i", type.getRows());
                             buffer += argBuffer;
                         }
                     }
diff --git a/src/compiler/translator/glslang_tab_autogen.cpp b/src/compiler/translator/glslang_tab_autogen.cpp
index 82837bf..28f7ed1 100644
--- a/src/compiler/translator/glslang_tab_autogen.cpp
+++ b/src/compiler/translator/glslang_tab_autogen.cpp
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison implementation for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/glslang_tab_autogen.h b/src/compiler/translator/glslang_tab_autogen.h
index d2eab0b..22011af 100644
--- a/src/compiler/translator/glslang_tab_autogen.h
+++ b/src/compiler/translator/glslang_tab_autogen.h
@@ -1,5 +1,7 @@
 /* A Bison parser, made by GNU Bison 3.3.2.  */
 
+/* Apple Note: For the avoidance of doubt, Apple elects to distribute this file under the terms of the BSD license. */
+
 /* Bison interface for Yacc-like parsers in C
 
    Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2019 Free Software Foundation,
diff --git a/src/compiler/translator/tree_ops/PruneEmptyCases.cpp b/src/compiler/translator/tree_ops/PruneEmptyCases.cpp
index 2fef999..ac2aa81 100644
--- a/src/compiler/translator/tree_ops/PruneEmptyCases.cpp
+++ b/src/compiler/translator/tree_ops/PruneEmptyCases.cpp
@@ -17,7 +17,7 @@ namespace sh
 namespace
 {
 
-bool AreEmptyBlocks(TIntermSequence *statements);
+bool AreEmptyBlocks(const TIntermSequence *statements);
 
 bool IsEmptyBlock(TIntermNode *node)
 {
@@ -37,7 +37,7 @@ bool IsEmptyBlock(TIntermNode *node)
 
 // Return true if all statements in "statements" consist only of empty blocks and no-op statements.
 // Returns true also if there are no statements.
-bool AreEmptyBlocks(TIntermSequence *statements)
+bool AreEmptyBlocks(const TIntermSequence *statements)
 {
     for (size_t i = 0u; i < statements->size(); ++i)
     {
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
index 55e2f8b..4237558 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.cpp
@@ -10,6 +10,7 @@
 #include "compiler/translator/tree_util/IntermNode_util.h"
 #include "compiler/translator/tree_util/IntermTraverse.h"
 
+#if defined(ANGLE_ENABLE_GLSL) && defined(ANGLE_ENABLE_APPLE_WORKAROUNDS)
 namespace sh
 {
 
@@ -70,5 +71,5 @@ bool UnfoldShortCircuitAST(TCompiler *compiler, TIntermBlock *root)
     root->traverse(&traverser);
     return traverser.updateTree(compiler, root);
 }
-
+#endif
 }  // namespace sh
diff --git a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
index ad3cc08..75069c5 100644
--- a/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
+++ b/src/compiler/translator/tree_ops/apple/UnfoldShortCircuitAST.h
@@ -11,7 +11,7 @@
 #define COMPILER_TRANSLATOR_TREEOPS_APPLE_UNFOLDSHORTCIRCUITAST_H_
 
 #include "common/angleutils.h"
-
+#include "common/debug.h"
 namespace sh
 {
 
diff --git a/src/libANGLE/State.cpp b/src/libANGLE/State.cpp
index 1535a99..a6016d5 100644
--- a/src/libANGLE/State.cpp
+++ b/src/libANGLE/State.cpp
@@ -6,6 +6,9 @@
 
 // State.cpp: Implements the State class, encapsulating raw GL state.
 
+// Older clang versions have a false positive on this warning here.
+#pragma clang diagnostic ignored "-Wglobal-constructors"
+
 #include "libANGLE/State.h"
 
 #include <string.h>
diff --git a/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp
new file mode 100644
index 0000000..801e604
--- /dev/null
+++ b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.cpp
@@ -0,0 +1,81 @@
+//
+// Copyright 2021 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// ShaderInterfaceVariableInfoMap.cpp:
+//    Implements helper class for shader compilers
+//
+
+#include "libANGLE/renderer/ShaderInterfaceVariableInfoMap.h"
+namespace rx
+{
+
+const uint32_t ShaderInterfaceVariableInfo::kInvalid;
+
+ShaderInterfaceVariableInfo::ShaderInterfaceVariableInfo() {}
+
+// ShaderInterfaceVariableInfoMap implementation.
+ShaderInterfaceVariableInfoMap::ShaderInterfaceVariableInfoMap() = default;
+
+ShaderInterfaceVariableInfoMap::~ShaderInterfaceVariableInfoMap() = default;
+
+void ShaderInterfaceVariableInfoMap::clear()
+{
+    for (VariableNameToInfoMap &shaderMap : mData)
+    {
+        shaderMap.clear();
+    }
+}
+
+bool ShaderInterfaceVariableInfoMap::contains(gl::ShaderType shaderType,
+                                              const std::string &variableName) const
+{
+    return mData[shaderType].find(variableName) != mData[shaderType].end();
+}
+
+const ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(
+    gl::ShaderType shaderType,
+    const std::string &variableName) const
+{
+    auto it = mData[shaderType].find(variableName);
+    ASSERT(it != mData[shaderType].end());
+    return it->second;
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(gl::ShaderType shaderType,
+                                                                 const std::string &variableName)
+{
+    auto it = mData[shaderType].find(variableName);
+    ASSERT(it != mData[shaderType].end());
+    return it->second;
+}
+
+void ShaderInterfaceVariableInfoMap::markAsDuplicate(gl::ShaderType shaderType,
+                                                     const std::string &variableName)
+{
+    ASSERT(contains(shaderType, variableName));
+    mData[shaderType][variableName].isDuplicate = true;
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::add(gl::ShaderType shaderType,
+                                                                 const std::string &variableName)
+{
+    ASSERT(!contains(shaderType, variableName));
+    return mData[shaderType][variableName];
+}
+
+ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::addOrGet(
+    gl::ShaderType shaderType,
+    const std::string &variableName)
+{
+    return mData[shaderType][variableName];
+}
+
+ShaderInterfaceVariableInfoMap::Iterator ShaderInterfaceVariableInfoMap::getIterator(
+    gl::ShaderType shaderType) const
+{
+    return Iterator(mData[shaderType].begin(), mData[shaderType].end());
+}
+
+}  // namespace rx
diff --git a/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h
new file mode 100644
index 0000000..851985a
--- /dev/null
+++ b/src/libANGLE/renderer/ShaderInterfaceVariableInfoMap.h
@@ -0,0 +1,63 @@
+//
+// Copyright 2021 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+// Header for the shared ShaderInterfaceVariableInfoMap class, used by both the
+// Metal and Direct Metal backends.
+#ifndef ShaderInterfaceVariableInfoMap_hpp
+#define ShaderInterfaceVariableInfoMap_hpp
+
+#include <functional>
+
+#include <stdio.h>
+#include "libANGLE/renderer/ProgramImpl.h"
+#include "libANGLE/renderer/glslang_wrapper_utils.h"
+#include "libANGLE/renderer/renderer_utils.h"
+namespace rx
+{
+
+// TODO: http://anglebug.com/4524: Need a different hash key than a string, since that's slow to
+// calculate.
+class ShaderInterfaceVariableInfoMap final : angle::NonCopyable
+{
+  public:
+    ShaderInterfaceVariableInfoMap();
+    ~ShaderInterfaceVariableInfoMap();
+
+    void clear();
+    bool contains(gl::ShaderType shaderType, const std::string &variableName) const;
+    const ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType,
+                                           const std::string &variableName) const;
+    ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType, const std::string &variableName);
+    ShaderInterfaceVariableInfo &add(gl::ShaderType shaderType, const std::string &variableName);
+    void markAsDuplicate(gl::ShaderType shaderType, const std::string &variableName);
+    ShaderInterfaceVariableInfo &addOrGet(gl::ShaderType shaderType,
+                                          const std::string &variableName);
+    size_t variableCount(gl::ShaderType shaderType) const { return mData[shaderType].size(); }
+
+    using VariableNameToInfoMap = angle::HashMap<std::string, ShaderInterfaceVariableInfo>;
+
+    class Iterator final
+    {
+      public:
+        Iterator(VariableNameToInfoMap::const_iterator beginIt,
+                 VariableNameToInfoMap::const_iterator endIt)
+            : mBeginIt(beginIt), mEndIt(endIt)
+        {}
+        VariableNameToInfoMap::const_iterator begin() { return mBeginIt; }
+        VariableNameToInfoMap::const_iterator end() { return mEndIt; }
+
+      private:
+        VariableNameToInfoMap::const_iterator mBeginIt;
+        VariableNameToInfoMap::const_iterator mEndIt;
+    };
+
+    Iterator getIterator(gl::ShaderType shaderType) const;
+
+  private:
+    gl::ShaderMap<VariableNameToInfoMap> mData;
+};
+
+}  // namespace rx
+#endif /* ShaderInterfaceVariableInfoMap_hpp */
diff --git a/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm b/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
index 07691a5..1a04eda 100644
--- a/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
+++ b/src/libANGLE/renderer/gl/eagl/DisplayEAGL.mm
@@ -404,7 +404,6 @@
 {
     return mRenderer.get();
 }
-
 }
 
 #endif  // defined(ANGLE_ENABLE_EAGL)
diff --git a/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm b/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
index 238d920..ce4520d 100644
--- a/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
+++ b/src/libANGLE/renderer/gl/eagl/IOSurfaceSurfaceEAGL.mm
@@ -38,8 +38,6 @@
     GLenum internalFormat;
     GLenum type;
 
-    size_t componentBytes;
-
     GLenum nativeInternalFormat;
     GLenum nativeFormat;
     GLenum nativeType;
@@ -48,12 +46,12 @@
 // clang-format off
 
 static const IOSurfaceFormatInfo kIOSurfaceFormats[] = {
-    {GL_RED,      GL_UNSIGNED_BYTE,  1, GL_R8,  GL_RED,  GL_UNSIGNED_BYTE },
-    {GL_R16UI,    GL_UNSIGNED_SHORT, 2, GL_R16UI, GL_RED_INTEGER,  GL_UNSIGNED_SHORT},
-    {GL_RG,       GL_UNSIGNED_BYTE,  2, GL_RG8,  GL_RG,   GL_UNSIGNED_BYTE },
-    {GL_RGB,      GL_UNSIGNED_BYTE,  4, GL_RGBA, GL_BGRA, GL_UNSIGNED_BYTE },
-    {GL_BGRA_EXT, GL_UNSIGNED_BYTE,  4, GL_RGBA, GL_BGRA, GL_UNSIGNED_BYTE },
-    {GL_RGBA,     GL_HALF_FLOAT,     8, GL_RGBA, GL_RGBA, GL_HALF_FLOAT    },
+    {GL_RED,      GL_UNSIGNED_BYTE,  GL_R8,   GL_RED,  GL_UNSIGNED_BYTE },
+    {GL_R16UI,    GL_UNSIGNED_SHORT, GL_R16UI, GL_RED_INTEGER,  GL_UNSIGNED_SHORT},
+    {GL_RG,       GL_UNSIGNED_BYTE,  GL_RG8,  GL_RG,   GL_UNSIGNED_BYTE },
+    {GL_RGB,      GL_UNSIGNED_BYTE,  GL_RGBA, GL_BGRA, GL_UNSIGNED_BYTE },
+    {GL_BGRA_EXT, GL_UNSIGNED_BYTE,  GL_RGBA, GL_BGRA, GL_UNSIGNED_BYTE },
+    {GL_RGBA,     GL_HALF_FLOAT,     GL_RGBA, GL_RGBA, GL_HALF_FLOAT    },
 };
 
 // clang-format on
@@ -321,13 +319,10 @@ int FindIOSurfaceFormatIndex(GLenum internalFormat, GLenum type)
     {
         return false;
     }
-
-    // Check that the format matches this IOSurface plane
-    if (IOSurfaceGetBytesPerElementOfPlane(ioSurface, plane) !=
-        kIOSurfaceFormats[formatIndex].componentBytes)
-    {
-        return false;
-    }
+    // FIXME: Check that the format matches this IOSurface plane for pixel formats that we know of.
+    // We could map IOSurfaceGetPixelFormat to expected type plane and format type.
+    // However, the caller might supply us non-public pixel format, which makes exhaustive checks
+    // problematic.
 
     return true;
 }
diff --git a/src/libANGLE/renderer/glslang_wrapper_utils.cpp b/src/libANGLE/renderer/glslang_wrapper_utils.cpp
index ac1799c..91d8dc6 100644
--- a/src/libANGLE/renderer/glslang_wrapper_utils.cpp
+++ b/src/libANGLE/renderer/glslang_wrapper_utils.cpp
@@ -4683,72 +4683,6 @@ UniformBindingInfo::UniformBindingInfo(uint32_t bindingIndex,
 
 UniformBindingInfo::UniformBindingInfo() {}
 
-// ShaderInterfaceVariableInfo implementation.
-ShaderInterfaceVariableInfo::ShaderInterfaceVariableInfo() {}
-
-// ShaderInterfaceVariableInfoMap implementation.
-ShaderInterfaceVariableInfoMap::ShaderInterfaceVariableInfoMap() = default;
-
-ShaderInterfaceVariableInfoMap::~ShaderInterfaceVariableInfoMap() = default;
-
-void ShaderInterfaceVariableInfoMap::clear()
-{
-    for (VariableNameToInfoMap &shaderMap : mData)
-    {
-        shaderMap.clear();
-    }
-}
-
-bool ShaderInterfaceVariableInfoMap::contains(gl::ShaderType shaderType,
-                                              const std::string &variableName) const
-{
-    return mData[shaderType].find(variableName) != mData[shaderType].end();
-}
-
-const ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(
-    gl::ShaderType shaderType,
-    const std::string &variableName) const
-{
-    auto it = mData[shaderType].find(variableName);
-    ASSERT(it != mData[shaderType].end());
-    return it->second;
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::get(gl::ShaderType shaderType,
-                                                                 const std::string &variableName)
-{
-    auto it = mData[shaderType].find(variableName);
-    ASSERT(it != mData[shaderType].end());
-    return it->second;
-}
-
-void ShaderInterfaceVariableInfoMap::markAsDuplicate(gl::ShaderType shaderType,
-                                                     const std::string &variableName)
-{
-    ASSERT(contains(shaderType, variableName));
-    mData[shaderType][variableName].isDuplicate = true;
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::add(gl::ShaderType shaderType,
-                                                                 const std::string &variableName)
-{
-    ASSERT(!contains(shaderType, variableName));
-    return mData[shaderType][variableName];
-}
-
-ShaderInterfaceVariableInfo &ShaderInterfaceVariableInfoMap::addOrGet(
-    gl::ShaderType shaderType,
-    const std::string &variableName)
-{
-    return mData[shaderType][variableName];
-}
-
-ShaderInterfaceVariableInfoMap::Iterator ShaderInterfaceVariableInfoMap::getIterator(
-    gl::ShaderType shaderType) const
-{
-    return Iterator(mData[shaderType].begin(), mData[shaderType].end());
-}
-
 // Strip indices from the name.  If there are non-zero indices, return false to indicate that this
 // image uniform doesn't require set/binding.  That is done on index 0.
 bool GetImageNameWithoutIndices(std::string *name)
diff --git a/src/libANGLE/renderer/glslang_wrapper_utils.h b/src/libANGLE/renderer/glslang_wrapper_utils.h
index 787193c..1a912a6 100644
--- a/src/libANGLE/renderer/glslang_wrapper_utils.h
+++ b/src/libANGLE/renderer/glslang_wrapper_utils.h
@@ -10,13 +10,13 @@
 #define LIBANGLE_RENDERER_GLSLANG_WRAPPER_UTILS_H_
 
 #include <functional>
-
-#include "common/spirv/spirv_types.h"
 #include "libANGLE/renderer/ProgramImpl.h"
 #include "libANGLE/renderer/renderer_utils.h"
 
 namespace rx
 {
+
+class ShaderInterfaceVariableInfoMap;
 constexpr gl::ShaderMap<const char *> kDefaultUniformNames = {
     {gl::ShaderType::Vertex, sh::vk::kDefaultUniformsNameVS},
     {gl::ShaderType::TessControl, sh::vk::kDefaultUniformsNameTCS},
@@ -136,48 +136,6 @@ struct ShaderInterfaceVariableInfo
     bool isDuplicate = false;
 };
 
-// TODO: http://anglebug.com/4524: Need a different hash key than a string, since that's slow to
-// calculate.
-class ShaderInterfaceVariableInfoMap final : angle::NonCopyable
-{
-  public:
-    ShaderInterfaceVariableInfoMap();
-    ~ShaderInterfaceVariableInfoMap();
-
-    void clear();
-    bool contains(gl::ShaderType shaderType, const std::string &variableName) const;
-    const ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType,
-                                           const std::string &variableName) const;
-    ShaderInterfaceVariableInfo &get(gl::ShaderType shaderType, const std::string &variableName);
-    ShaderInterfaceVariableInfo &add(gl::ShaderType shaderType, const std::string &variableName);
-    void markAsDuplicate(gl::ShaderType shaderType, const std::string &variableName);
-    ShaderInterfaceVariableInfo &addOrGet(gl::ShaderType shaderType,
-                                          const std::string &variableName);
-    size_t variableCount(gl::ShaderType shaderType) const { return mData[shaderType].size(); }
-
-    using VariableNameToInfoMap = angle::HashMap<std::string, ShaderInterfaceVariableInfo>;
-
-    class Iterator final
-    {
-      public:
-        Iterator(VariableNameToInfoMap::const_iterator beginIt,
-                 VariableNameToInfoMap::const_iterator endIt)
-            : mBeginIt(beginIt), mEndIt(endIt)
-        {}
-        VariableNameToInfoMap::const_iterator begin() { return mBeginIt; }
-        VariableNameToInfoMap::const_iterator end() { return mEndIt; }
-
-      private:
-        VariableNameToInfoMap::const_iterator mBeginIt;
-        VariableNameToInfoMap::const_iterator mEndIt;
-    };
-
-    Iterator getIterator(gl::ShaderType shaderType) const;
-
-  private:
-    gl::ShaderMap<VariableNameToInfoMap> mData;
-};
-
 bool GetImageNameWithoutIndices(std::string *name);
 
 // Get the mapped sampler name.
@@ -199,7 +157,7 @@ void GlslangAssignTransformFeedbackLocations(gl::ShaderType shaderType,
                                              bool isTransformFeedbackStage,
                                              GlslangProgramInterfaceInfo *programInterfaceInfo,
                                              ShaderInterfaceVariableInfoMap *variableInfoMapOut);
-
+#if ANGLE_ENABLE_METAL_SPIRV
 // Retrieves the compiled SPIR-V code for each shader stage, and calls |GlslangAssignLocations|.
 void GlslangGetShaderSpirvCode(const GlslangSourceOptions &options,
                                const gl::ProgramState &programState,
@@ -210,8 +168,9 @@ void GlslangGetShaderSpirvCode(const GlslangSourceOptions &options,
 
 angle::Result GlslangTransformSpirvCode(const GlslangSpirvOptions &options,
                                         const ShaderInterfaceVariableInfoMap &variableInfoMap,
-                                        const angle::spirv::Blob &initialSpirvBlob,
+                                        const angle::qBlob &initialSpirvBlob,
                                         angle::spirv::Blob *spirvBlobOut);
+#endif
 
 }  // namespace rx
 
diff --git a/src/libANGLE/renderer/metal/BufferMtl.h b/src/libANGLE/renderer/metal/BufferMtl.h
index d5f20ee..e426b93 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.h
+++ b/src/libANGLE/renderer/metal/BufferMtl.h
@@ -189,8 +189,8 @@ class BufferMtl : public BufferImpl, public BufferHolderMtl
     angle::Result commitShadowCopy(const gl::Context *context, size_t size);
 
     void markConversionBuffersDirty();
-
     void clearConversionBuffers();
+
     bool clientShadowCopyDataNeedSync(ContextMtl *contextMtl);
     void ensureShadowCopySyncedFromGPU(ContextMtl *contextMtl);
     uint8_t *syncAndObtainShadowCopy(ContextMtl *contextMtl);
@@ -213,7 +213,19 @@ class BufferMtl : public BufferImpl, public BufferHolderMtl
     
     std::vector<UniformConversionBufferMtl> mUniformConversionBuffers;
 
-    bool mRestartIndicesDirty;
+    struct RestartRangeCache
+    {
+        RestartRangeCache() : indexType(gl::DrawElementsType::InvalidEnum) { isDirty = true; }
+        RestartRangeCache(std::vector<IndexRange> &&ranges_, gl::DrawElementsType indexType_)
+            : ranges(ranges_), indexType(indexType_), isDirty(false)
+        {}
+        void markDirty() { isDirty = true; }
+        operator bool() const { return isDirty; }
+        std::vector<IndexRange> ranges;
+        gl::DrawElementsType indexType;
+        bool isDirty;
+    };
+    RestartRangeCache mRestartRangeCache;
     std::vector<IndexRange> mRestartIndices;
 };
 
diff --git a/src/libANGLE/renderer/metal/BufferMtl.mm b/src/libANGLE/renderer/metal/BufferMtl.mm
index 0391303..dd394cf 100644
--- a/src/libANGLE/renderer/metal/BufferMtl.mm
+++ b/src/libANGLE/renderer/metal/BufferMtl.mm
@@ -365,7 +365,7 @@
     {
         if (buffer.offset == offset)
         {
-            return &buffer;
+            return static_cast<ConversionBufferMtl *>(&buffer);
         }
     }
 
@@ -395,7 +395,7 @@
         buffer.convertedBuffer = nullptr;
         buffer.convertedOffset = 0;
     }
-    mRestartIndicesDirty = true;
+    mRestartRangeCache.markDirty();
 }
 
 void BufferMtl::clearConversionBuffers()
@@ -403,6 +403,7 @@
     mVertexConversionBuffers.clear();
     mIndexConversionBuffers.clear();
     mUniformConversionBuffers.clear();
+    mRestartRangeCache.markDirty();
 }
 
 template <typename T>
@@ -432,26 +433,27 @@
 const std::vector<IndexRange> &BufferMtl::getRestartIndices(ContextMtl *ctx,
                                                             gl::DrawElementsType indexType)
 {
-    if (mRestartIndicesDirty)
+    if (!mRestartRangeCache || mRestartRangeCache.indexType != indexType)
     {
-        std::vector<IndexRange>().swap(mRestartIndices);
+        mRestartRangeCache.markDirty();
+        std::vector<IndexRange> ranges;
         switch (indexType)
         {
             case gl::DrawElementsType::UnsignedByte:
-                mRestartIndices = calculateRestartRanges<uint8_t>(ctx, getCurrentBuffer());
+                ranges = calculateRestartRanges<uint8_t>(ctx, getCurrentBuffer());
                 break;
             case gl::DrawElementsType::UnsignedShort:
-                mRestartIndices = calculateRestartRanges<uint16_t>(ctx, getCurrentBuffer());
+                ranges = calculateRestartRanges<uint16_t>(ctx, getCurrentBuffer());
                 break;
             case gl::DrawElementsType::UnsignedInt:
-                mRestartIndices = calculateRestartRanges<uint32_t>(ctx, getCurrentBuffer());
+                ranges = calculateRestartRanges<uint32_t>(ctx, getCurrentBuffer());
                 break;
             default:
                 ASSERT(false);
         }
-        mRestartIndicesDirty = false;
+        mRestartRangeCache = RestartRangeCache(std::move(ranges), indexType);
     }
-    return mRestartIndices;
+    return mRestartRangeCache.ranges;
 }
 
 const std::vector<IndexRange> BufferMtl::getRestartIndicesFromClientData(
@@ -518,7 +520,7 @@
         default:
             // dynamic buffer, allow up to 10 update per frame/encoding without
             // waiting for GPU.
-            if (adjustedSize <= mtl::kSharedMemBufferMaxBufSizeHint)
+            if (adjustedSize <= kConvertedElementArrayBufferInitialSize)
             {
                 maxBuffers = 10;
                 mBufferPool.setAlwaysUseSharedMem();
diff --git a/src/libANGLE/renderer/metal/ContextMtl.mm b/src/libANGLE/renderer/metal/ContextMtl.mm
index 2933264..da0c67d 100644
--- a/src/libANGLE/renderer/metal/ContextMtl.mm
+++ b/src/libANGLE/renderer/metal/ContextMtl.mm
@@ -2354,7 +2354,7 @@ bool IsTransformFeedbackOnly(const gl::State &glState)
 
 angle::Result ContextMtl::handleDirtyDepthBias(const gl::Context *context)
 {
-    const gl::RasterizerState &raserState = mState.getRasterizerState();
+    const gl::RasterizerState &rasterState = mState.getRasterizerState();
     ASSERT(mRenderEncoder.valid());
     if (!mState.isPolygonOffsetFillEnabled())
     {
@@ -2362,7 +2362,7 @@ bool IsTransformFeedbackOnly(const gl::State &glState)
     }
     else
     {
-        mRenderEncoder.setDepthBias(raserState.polygonOffsetUnits, raserState.polygonOffsetFactor,
+        mRenderEncoder.setDepthBias(rasterState.polygonOffsetUnits, rasterState.polygonOffsetFactor,
                                     0);
     }
 
diff --git a/src/libANGLE/renderer/metal/DisplayMtl.mm b/src/libANGLE/renderer/metal/DisplayMtl.mm
index 2136fc2..f523c6e 100644
--- a/src/libANGLE/renderer/metal/DisplayMtl.mm
+++ b/src/libANGLE/renderer/metal/DisplayMtl.mm
@@ -27,6 +27,10 @@
 #include "libANGLE/trace.h"
 #include "platform/Platform.h"
 
+#ifdef ANGLE_METAL_XCODE_BUILDS_SHADERS
+#include "mtl_default_shaders_compiled.inc"
+#endif
+
 #include "EGL/eglext.h"
 
 #if defined(ANGLE_PLATFORM_MACOS) || defined(ANGLE_PLATFORM_MACCATALYST)
@@ -1173,155 +1177,12 @@ bool IsMetalDisplayAvailable()
 
 bool DisplayMtl::supportsAppleGPUFamily(uint8_t iOSFamily) const
 {
-#if TARGET_OS_MACCATALYST
-    return false;
-#else
-#    if (__IPHONE_OS_VERSION_MAX_ALLOWED >= 130000) || (__TV_OS_VERSION_MAX_ALLOWED >= 130000) || \
-        (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101500)
-    // If device supports [MTLDevice supportsFamily:], then use it.
-    if (ANGLE_APPLE_AVAILABLE_XI(10.15, 13.0))
-    {
-        MTLGPUFamily family;
-        switch (iOSFamily)
-        {
-            case 1:
-                family = MTLGPUFamilyApple1;
-                break;
-            case 2:
-                family = MTLGPUFamilyApple2;
-                break;
-            case 3:
-                family = MTLGPUFamilyApple3;
-                break;
-            case 4:
-                family = MTLGPUFamilyApple4;
-                break;
-            case 5:
-                family = MTLGPUFamilyApple5;
-                break;
-#        if TARGET_OS_IOS || (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
-            case 6:
-                family = MTLGPUFamilyApple6;
-                break;
-#        endif
-#        if (TARGET_OS_IOS && (__IPHONE_OS_VERSION_MAX_ALLOWED >= 140000)) || \
-            (TARGET_OS_OSX && (__MAC_OS_X_VERSION_MAX_ALLOWED >= 101600))
-            case 7:
-                family = MTLGPUFamilyApple7;
-                break;
-#        endif
-            default:
-                return false;
-        }
-        return [getMetalDevice() supportsFamily:family];
-    }  // Metal 2.2
-#    endif  // __IPHONE_OS_VERSION_MAX_ALLOWED
-
-    // If device doesn't support [MTLDevice supportsFamily:], then use
-    // [MTLDevice supportsFeatureSet:].
-#    if TARGET_OS_IOS || TARGET_OS_TV
-    MTLFeatureSet featureSet;
-#    endif
-    switch (iOSFamily)
-    {
-#    if TARGET_OS_IOS
-        case 1:
-            featureSet = MTLFeatureSet_iOS_GPUFamily1_v1;
-            break;
-        case 2:
-            featureSet = MTLFeatureSet_iOS_GPUFamily2_v1;
-            break;
-        case 3:
-            featureSet = MTLFeatureSet_iOS_GPUFamily3_v1;
-            break;
-        case 4:
-            featureSet = MTLFeatureSet_iOS_GPUFamily4_v1;
-            break;
-#        if __IPHONE_OS_VERSION_MAX_ALLOWED >= 120000
-        case 5:
-            featureSet = MTLFeatureSet_iOS_GPUFamily5_v1;
-            break;
-#        endif  // __IPHONE_OS_VERSION_MAX_ALLOWED
-#    elif TARGET_OS_TV
-        case 1:
-        case 2:
-            featureSet = MTLFeatureSet_tvOS_GPUFamily1_v1;
-            break;
-        case 3:
-            featureSet = MTLFeatureSet_tvOS_GPUFamily2_v1;
-            break;
-#    endif  // TARGET_OS_IOS
-        default:
-            return false;
-    }
-
-#    if TARGET_OS_IOS || TARGET_OS_TV
-    return [getMetalDevice() supportsFeatureSet:featureSet];
-#    endif
-#endif  // TARGET_OS_MACCATALYST
+    return mtl::SupportsAppleGPUFamily(getMetalDevice(), iOSFamily);
 }
 
 bool DisplayMtl::supportsMacGPUFamily(uint8_t macFamily) const
 {
-#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
-#    if defined(__MAC_10_15)
-    // If device supports [MTLDevice supportsFamily:], then use it.
-    if (ANGLE_APPLE_AVAILABLE_XC(10.15, 13.0))
-    {
-        MTLGPUFamily family;
-
-        switch (macFamily)
-        {
-#        if TARGET_OS_MACCATALYST
-            case 1:
-                family = MTLGPUFamilyMacCatalyst1;
-                break;
-            case 2:
-                family = MTLGPUFamilyMacCatalyst2;
-                break;
-#        else   // TARGET_OS_MACCATALYST
-            case 1:
-                family = MTLGPUFamilyMac1;
-                break;
-            case 2:
-                family = MTLGPUFamilyMac2;
-                break;
-#        endif  // TARGET_OS_MACCATALYST
-            default:
-                return false;
-        }
-
-        return [getMetalDevice() supportsFamily:family];
-    }  // Metal 2.2
-#    endif
-
-    // If device doesn't support [MTLDevice supportsFamily:], then use
-    // [MTLDevice supportsFeatureSet:].
-#    if TARGET_OS_MACCATALYST
-    UNREACHABLE();
-    return false;
-#    else
-    MTLFeatureSet featureSet;
-    switch (macFamily)
-    {
-        case 1:
-            featureSet = MTLFeatureSet_macOS_GPUFamily1_v1;
-            break;
-#        if defined(__MAC_10_14)
-        case 2:
-            featureSet = MTLFeatureSet_macOS_GPUFamily2_v1;
-            break;
-#        endif
-        default:
-            return false;
-    }
-    return [getMetalDevice() supportsFeatureSet:featureSet];
-#    endif  // TARGET_OS_MACCATALYST
-#else       // #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
-
-    return false;
-
-#endif
+    return mtl::SupportsMacGPUFamily(getMetalDevice(), macFamily);
 }
 
 bool DisplayMtl::supportsEitherGPUFamily(uint8_t iOSFamily, uint8_t macFamily) const
diff --git a/src/libANGLE/renderer/metal/FrameBufferMtl.mm b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
index 6de7e81..1e07347 100644
--- a/src/libANGLE/renderer/metal/FrameBufferMtl.mm
+++ b/src/libANGLE/renderer/metal/FrameBufferMtl.mm
@@ -809,9 +809,7 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     mtl::RenderPassAttachmentDesc &attachment = *attachmentOut;
 
-    if (!forceDepthStencilMultisampleLoad &&
-        (attachment.storeAction == MTLStoreActionDontCare ||
-         attachment.storeAction == MTLStoreActionMultisampleResolve))
+    if (!forceDepthStencilMultisampleLoad && attachment.storeAction == MTLStoreActionDontCare)
     {
         // If we previously discarded attachment's content, then don't need to load it.
         attachment.loadAction = MTLLoadActionDontCare;
@@ -1613,5 +1611,4 @@ void RoundValueAndAdjustCorrespondingValue(float a,
 
     return angle::Result::Continue;
 }
-
 }
diff --git a/src/libANGLE/renderer/metal/ProgramMtl.h b/src/libANGLE/renderer/metal/ProgramMtl.h
index 9baeea2..b33dd99 100644
--- a/src/libANGLE/renderer/metal/ProgramMtl.h
+++ b/src/libANGLE/renderer/metal/ProgramMtl.h
@@ -18,6 +18,7 @@
 #include "common/Optional.h"
 #include "common/utilities.h"
 #include "libANGLE/renderer/ProgramImpl.h"
+#include "libANGLE/renderer/ShaderInterfaceVariableInfoMap.h"
 #include "libANGLE/renderer/glslang_wrapper_utils.h"
 #include "libANGLE/renderer/metal/mtl_buffer_pool.h"
 #include "libANGLE/renderer/metal/mtl_command_buffer.h"
diff --git a/src/libANGLE/renderer/metal/ShaderMtl.mm b/src/libANGLE/renderer/metal/ShaderMtl.mm
index 5a38afa..767dd3c 100644
--- a/src/libANGLE/renderer/metal/ShaderMtl.mm
+++ b/src/libANGLE/renderer/metal/ShaderMtl.mm
@@ -155,7 +155,12 @@ bool postTranslate(std::string *infoLog) override
 
 std::string ShaderMtl::getDebugInfo() const
 {
+    std::string debugInfo = mState.getTranslatedSource();
+    if (debugInfo.empty())
+    {
         return mState.getCompiledBinary().empty() ? "" : "<binary blob>";
+    }
+    return debugInfo;
 }
 
 }  // namespace rx
diff --git a/src/libANGLE/renderer/metal/SurfaceMtl.mm b/src/libANGLE/renderer/metal/SurfaceMtl.mm
index 161ed51..95006fe 100644
--- a/src/libANGLE/renderer/metal/SurfaceMtl.mm
+++ b/src/libANGLE/renderer/metal/SurfaceMtl.mm
@@ -770,5 +770,4 @@
 {
     mSize.height = height;
 }
-
 }
diff --git a/src/libANGLE/renderer/metal/TextureMtl.mm b/src/libANGLE/renderer/metal/TextureMtl.mm
index 3c7f2f0..a659d8e 100644
--- a/src/libANGLE/renderer/metal/TextureMtl.mm
+++ b/src/libANGLE/renderer/metal/TextureMtl.mm
@@ -1287,11 +1287,11 @@ GLenum OverrideSwizzleValue(const gl::Context *context,
     //
     bool sRGB = mFormat.actualInternalFormat().colorEncoding == GL_SRGB;
 
-    bool avoidCSPath =
+    bool avoidGPUPath =
         contextMtl->getDisplay()->getFeatures().forceNonCSBaseMipmapGeneration.enabled &&
         mNativeTexture->widthAt0() < 5;
 
-    if (!avoidCSPath && caps.writable && mState.getType() == gl::TextureType::_3D)
+    if (!avoidGPUPath && caps.writable && mState.getType() == gl::TextureType::_3D)
     {
         // http://anglebug.com/4921.
         // Use compute for 3D mipmap generation.
@@ -1299,7 +1299,7 @@ GLenum OverrideSwizzleValue(const gl::Context *context,
         ANGLE_TRY(contextMtl->getDisplay()->getUtils().generateMipmapCS(contextMtl, mNativeTexture,
                                                                         sRGB, &mNativeLevelViews));
     }
-    else if (caps.filterable && caps.colorRenderable)
+    else if (!avoidGPUPath && caps.filterable && caps.colorRenderable)
     {
         mtl::BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
         blitEncoder->generateMipmapsForTexture(mNativeTexture);
diff --git a/src/libANGLE/renderer/metal/gen_mtl_format_table.py b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
index 6232409..6788b42 100644
--- a/src/libANGLE/renderer/metal/gen_mtl_format_table.py
+++ b/src/libANGLE/renderer/metal/gen_mtl_format_table.py
@@ -36,6 +36,7 @@ template_autogen_inl = """// GENERATED FILE - DO NOT EDIT.
 #include "libANGLE/renderer/Format.h"
 #include "libANGLE/renderer/metal/DisplayMtl.h"
 #include "libANGLE/renderer/metal/mtl_format_utils.h"
+#include "libANGLE/renderer/metal/mtl_utils.h"
 
 using namespace angle;
 
@@ -56,8 +57,9 @@ angle::FormatID Format::MetalToAngleFormatID(MTLPixelFormat formatMtl)
 void Format::init(const DisplayMtl *display, angle::FormatID intendedFormatId_)
 {{
     this->intendedFormatId = intendedFormatId_;
-
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     id<MTLDevice> metalDevice = display->getMetalDevice();
+#endif
 
     // Actual conversion
     switch (this->intendedFormatId)
@@ -116,6 +118,23 @@ image_format_assign_template2 = """
                 this->initFunction = {init_function_fallback};
             }}
 """
+#D16 is fully supported on  Apple3+. However, on
+#previous  versions of Apple hardware, some operations can cause
+#undefined behavior.
+image_format_assign_template3 = """
+            if (mtl::SupportsIOSGPUFamily(metalDevice, 3))
+            {{
+                this->metalFormat = {mtl_format};
+                this->actualFormatId = angle::FormatID::{actual_angle_format};
+                this->initFunction = {init_function};
+            }}
+            else
+            {{
+                this->metalFormat = {mtl_format_fallback};
+                this->actualFormatId = angle::FormatID::{actual_angle_format_fallback};
+                this->initFunction = {init_function_fallback};
+            }}
+"""
 
 case_image_format_template1 = """        case angle::FormatID::{angle_format}:
             {image_format_assign}
@@ -225,6 +244,8 @@ def get_vertex_copy_function_and_default_alpha(src_format, dst_format):
 
 
 # Generate format conversion switch case (generic case)
+
+
 def gen_image_map_switch_case(angle_format, actual_angle_format_info, angle_to_mtl_map,
                               assign_gen_func):
     if isinstance(actual_angle_format_info, dict):
@@ -267,6 +288,8 @@ def gen_image_map_switch_case(angle_format, actual_angle_format_info, angle_to_m
 
 
 # Generate format conversion switch case (simple case)
+
+
 def gen_image_map_switch_simple_case(angle_format, actual_angle_format_info, angle_to_gl,
                                      angle_to_mtl_map):
 
@@ -282,6 +305,8 @@ def gen_image_map_switch_simple_case(angle_format, actual_angle_format_info, ang
 
 
 # Generate format conversion switch case (Mac case)
+
+
 def gen_image_map_switch_mac_case(angle_format, actual_angle_format_info, angle_to_gl,
                                   angle_to_mtl_map, mac_fallbacks):
     gl_format = angle_to_gl[angle_format]
@@ -369,6 +394,8 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     mac_specific_map = image_table["map_mac"]
     ios_specific_map = image_table["map_ios"]
     astc_tpl_map = image_table["map_astc_tpl"]
+    sim_specific_map = image_table["map_sim"]
+    sim_override = image_table["override_sim"]
 
     # mac_specific_map + angle_to_mtl:
     mac_angle_to_mtl = mac_specific_map.copy()
@@ -376,7 +403,9 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
     # ios_specific_map + angle_to_mtl
     ios_angle_to_mtl = ios_specific_map.copy()
     ios_angle_to_mtl.update(angle_to_mtl)
-
+    # sim_specific_map + angle_to_mtl
+    sim_angle_to_mtl = sim_specific_map.copy()
+    sim_angle_to_mtl.update(angle_to_mtl)
     switch_data = ''
 
     def gen_image_map_switch_common_case(angle_format, actual_angle_format):
@@ -410,8 +439,16 @@ def gen_image_map_switch_string(image_table, angle_to_gl):
         switch_data += gen_image_map_switch_simple_case(angle_format,
                                                         mac_override_es3[angle_format],
                                                         angle_to_gl, mac_angle_to_mtl)
-    switch_data += "#endif\n"
 
+    switch_data += "#elif TARGET_OS_SIMULATOR\n"
+    for angle_format in sorted(sim_specific_map.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, angle_format, angle_to_gl,
+                                                        sim_specific_map)
+    for angle_format in sorted(sim_override.keys()):
+        switch_data += gen_image_map_switch_simple_case(angle_format, sim_override[angle_format],
+                                                        angle_to_gl, sim_angle_to_mtl)
+
+    switch_data += "#endif\n"
     # iOS specific
     switch_data += "#if TARGET_OS_IOS || TARGET_OS_TV\n"
     for angle_format in sorted(ios_specific_map.keys()):
diff --git a/src/libANGLE/renderer/metal/mtl_buffer_pool.h b/src/libANGLE/renderer/metal/mtl_buffer_pool.h
index c3be11f..204ebb9 100644
--- a/src/libANGLE/renderer/metal/mtl_buffer_pool.h
+++ b/src/libANGLE/renderer/metal/mtl_buffer_pool.h
@@ -126,7 +126,7 @@ class BufferPool
 
     size_t mBuffersAllocated;
     size_t mMaxBuffers;
-    BufferPoolMemPolicy mMemPolicy;
+    BufferPoolMemPolicy mMemPolicy = BufferPoolMemPolicy::Auto;
     bool mAlwaysAllocateNewBuffer;
 };
 
diff --git a/src/libANGLE/renderer/metal/mtl_format_map.json b/src/libANGLE/renderer/metal/mtl_format_map.json
index 2a63665..29e96ee 100644
--- a/src/libANGLE/renderer/metal/mtl_format_map.json
+++ b/src/libANGLE/renderer/metal/mtl_format_map.json
@@ -74,7 +74,6 @@
             "D32_FLOAT": "MTLPixelFormatDepth32Float",
             "S8_UINT": "MTLPixelFormatStencil8",
             "D32_FLOAT_S8X24_UINT": "MTLPixelFormatDepth32Float_Stencil8",
-            "B10G10R10A2_UNORM": "MTLPixelFormatBGR10A2Unorm",
             "R10G10B10A2_UINT": "MTLPixelFormatRGB10A2Uint",
             "R10G10B10A2_UNORM": "MTLPixelFormatRGB10A2Unorm",
             "R11G11B10_FLOAT": "MTLPixelFormatRG11B10Float",
@@ -105,20 +104,20 @@
             "EAC_R11_SNORM_BLOCK": "MTLPixelFormatEAC_R11Snorm",
             "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_RG11Unorm",
             "EAC_R11G11_SNORM_BLOCK": "MTLPixelFormatEAC_RG11Snorm",
-            "ASTC_4x4_SRGB_BLOCK": "MTLPixelFormatASTC_4x4_sRGB",
-            "ASTC_5x4_SRGB_BLOCK": "MTLPixelFormatASTC_5x4_sRGB",
-            "ASTC_5x5_SRGB_BLOCK": "MTLPixelFormatASTC_5x5_sRGB",
-            "ASTC_6x5_SRGB_BLOCK": "MTLPixelFormatASTC_6x5_sRGB",
-            "ASTC_6x6_SRGB_BLOCK": "MTLPixelFormatASTC_6x6_sRGB",
-            "ASTC_8x5_SRGB_BLOCK": "MTLPixelFormatASTC_8x5_sRGB",
-            "ASTC_8x6_SRGB_BLOCK": "MTLPixelFormatASTC_8x6_sRGB",
-            "ASTC_8x8_SRGB_BLOCK": "MTLPixelFormatASTC_8x8_sRGB",
-            "ASTC_10x5_SRGB_BLOCK": "MTLPixelFormatASTC_10x5_sRGB",
-            "ASTC_10x6_SRGB_BLOCK": "MTLPixelFormatASTC_10x6_sRGB",
-            "ASTC_10x8_SRGB_BLOCK": "MTLPixelFormatASTC_10x8_sRGB",
-            "ASTC_10x10_SRGB_BLOCK": "MTLPixelFormatASTC_10x10_sRGB",
-            "ASTC_12x10_SRGB_BLOCK": "MTLPixelFormatASTC_12x10_sRGB",
-            "ASTC_12x12_SRGB_BLOCK": "MTLPixelFormatASTC_12x12_sRGB"
+            "ASTC_4x4_SRGB_BLOCK" : "MTLPixelFormatASTC_4x4_sRGB",
+            "ASTC_5x4_SRGB_BLOCK" : "MTLPixelFormatASTC_5x4_sRGB",
+            "ASTC_5x5_SRGB_BLOCK" : "MTLPixelFormatASTC_5x5_sRGB",
+            "ASTC_6x5_SRGB_BLOCK" : "MTLPixelFormatASTC_6x5_sRGB",
+            "ASTC_6x6_SRGB_BLOCK" : "MTLPixelFormatASTC_6x6_sRGB",
+            "ASTC_8x5_SRGB_BLOCK" : "MTLPixelFormatASTC_8x5_sRGB",
+            "ASTC_8x6_SRGB_BLOCK" : "MTLPixelFormatASTC_8x6_sRGB",
+            "ASTC_8x8_SRGB_BLOCK" : "MTLPixelFormatASTC_8x8_sRGB",
+            "ASTC_10x5_SRGB_BLOCK" : "MTLPixelFormatASTC_10x5_sRGB",
+            "ASTC_10x6_SRGB_BLOCK" : "MTLPixelFormatASTC_10x6_sRGB",
+            "ASTC_10x8_SRGB_BLOCK" : "MTLPixelFormatASTC_10x8_sRGB",
+            "ASTC_10x10_SRGB_BLOCK" : "MTLPixelFormatASTC_10x10_sRGB",
+            "ASTC_12x10_SRGB_BLOCK" : "MTLPixelFormatASTC_12x10_sRGB",
+            "ASTC_12x12_SRGB_BLOCK" : "MTLPixelFormatASTC_12x12_sRGB"
         },
         "map_sim": {
             "ETC1_R8G8B8_UNORM_BLOCK": "MTLPixelFormatETC2_RGB8",
@@ -130,7 +129,7 @@
             "ETC2_R8G8B8A8_SRGB_BLOCK": "MTLPixelFormatEAC_RGBA8_sRGB",
             "EAC_R11_UNORM_BLOCK": "MTLPixelFormatEAC_R11Unorm",
             "EAC_R11_SNORM_BLOCK": "MTLPixelFormatEAC_R11Snorm",
-            "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_R11Unorm",
+            "EAC_R11G11_UNORM_BLOCK": "MTLPixelFormatEAC_RG11Unorm",
             "EAC_R11G11_SNORM_BLOCK": "MTLPixelFormatEAC_RG11Snorm",
             "ASTC_4x4_SRGB_BLOCK": "MTLPixelFormatASTC_4x4_sRGB",
             "ASTC_5x4_SRGB_BLOCK": "MTLPixelFormatASTC_5x4_sRGB",
@@ -261,6 +260,8 @@
         "d24s8_fallbacks_mac": {
             "D24_UNORM_S8_UINT": "D32_FLOAT_S8X24_UINT"
         },
+        "fallbacks_ios": {
+        },
         "caps": {
             "MTLPixelFormatA8Unorm":{
                 "filterable": "true",
diff --git a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
index 4c63ca4..e2ea7e5 100644
--- a/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
+++ b/src/libANGLE/renderer/metal/mtl_format_table_autogen.mm
@@ -17,6 +17,7 @@
 #include "libANGLE/renderer/Format.h"
 #include "libANGLE/renderer/metal/DisplayMtl.h"
 #include "libANGLE/renderer/metal/mtl_format_utils.h"
+#include "libANGLE/renderer/metal/mtl_utils.h"
 
 using namespace angle;
 
@@ -32,8 +33,6 @@
     {
         case MTLPixelFormatA8Unorm:
             return angle::FormatID::A8_UNORM;
-        case MTLPixelFormatBGR10A2Unorm:
-            return angle::FormatID::B10G10R10A2_UNORM;
         case MTLPixelFormatBGRA8Unorm:
             return angle::FormatID::B8G8R8A8_UNORM;
         case MTLPixelFormatBGRA8Unorm_sRGB:
@@ -300,8 +299,9 @@
 void Format::init(const DisplayMtl *display, angle::FormatID intendedFormatId_)
 {
     this->intendedFormatId = intendedFormatId_;
-
+#if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     id<MTLDevice> metalDevice = display->getMetalDevice();
+#endif
 
     // Actual conversion
     switch (this->intendedFormatId)
@@ -315,15 +315,6 @@
             this->swizzled = false;
             break;
 
-        case angle::FormatID::B10G10R10A2_UNORM:
-
-            this->metalFormat    = MTLPixelFormatBGR10A2Unorm;
-            this->actualFormatId = angle::FormatID::B10G10R10A2_UNORM;
-            this->initFunction   = nullptr;
-
-            this->swizzled = false;
-            break;
-
         case angle::FormatID::B8G8R8A8_UNORM:
             
             this->metalFormat = MTLPixelFormatBGRA8Unorm;
@@ -796,8 +787,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA16Float;
             this->actualFormatId = angle::FormatID::R16G16B16A16_FLOAT;
-            this->initFunction =
-                Initialize4ComponentData<GLhalf, 0x0000, 0x0000, 0x0000, gl::Float16One>;
+            this->initFunction = Initialize4ComponentData<GLhalf, 0x0000, 0x0000, 0x0000, gl::Float16One>;
 
             this->swizzled = false;
             break;
@@ -815,8 +805,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA32Float;
             this->actualFormatId = angle::FormatID::R32G32B32A32_FLOAT;
-            this->initFunction   = Initialize4ComponentData<GLfloat, 0x00000000, 0x00000000,
-                                                          0x00000000, gl::Float32One>;
+            this->initFunction = Initialize4ComponentData<GLfloat, 0x00000000, 0x00000000, 0x00000000, gl::Float32One>;
 
             this->swizzled = false;
             break;
@@ -843,8 +832,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA16Float;
             this->actualFormatId = angle::FormatID::R16G16B16A16_FLOAT;
-            this->initFunction =
-                Initialize4ComponentData<GLhalf, 0x0000, 0x0000, 0x0000, gl::Float16One>;
+            this->initFunction = Initialize4ComponentData<GLhalf, 0x0000, 0x0000, 0x0000, gl::Float16One>;
 
             this->swizzled = false;
             break;
@@ -889,8 +877,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA32Float;
             this->actualFormatId = angle::FormatID::R32G32B32A32_FLOAT;
-            this->initFunction   = Initialize4ComponentData<GLfloat, 0x00000000, 0x00000000,
-                                                          0x00000000, gl::Float32One>;
+            this->initFunction = Initialize4ComponentData<GLfloat, 0x00000000, 0x00000000, 0x00000000, gl::Float32One>;
 
             this->swizzled = false;
             break;
@@ -899,8 +886,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA32Sint;
             this->actualFormatId = angle::FormatID::R32G32B32A32_SINT;
-            this->initFunction =
-                Initialize4ComponentData<GLint, 0x00000000, 0x00000000, 0x00000000, 0x00000001>;
+            this->initFunction = Initialize4ComponentData<GLint, 0x00000000, 0x00000000, 0x00000000, 0x00000001>;
 
             this->swizzled = false;
             break;
@@ -909,8 +895,7 @@
             
             this->metalFormat = MTLPixelFormatRGBA32Uint;
             this->actualFormatId = angle::FormatID::R32G32B32A32_UINT;
-            this->initFunction =
-                Initialize4ComponentData<GLuint, 0x00000000, 0x00000000, 0x00000000, 0x00000001>;
+            this->initFunction = Initialize4ComponentData<GLuint, 0x00000000, 0x00000000, 0x00000000, 0x00000001>;
 
             this->swizzled = false;
             break;
@@ -1116,7 +1101,7 @@
             break;
 
         case angle::FormatID::BC1_RGB_UNORM_BLOCK:
-#    if defined(__IPHONE_13_0) || defined(__MAC_10_15)
+#if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             if (display->getFeatures().hasTextureSwizzle.enabled)
             {
                 
@@ -1128,7 +1113,7 @@
                 this->swizzle  = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
             }
             else
-#    endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
+#endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             {
                 
             this->metalFormat = MTLPixelFormatBC1_RGBA;
@@ -1140,7 +1125,7 @@
             break;
 
         case angle::FormatID::BC1_RGB_UNORM_SRGB_BLOCK:
-#    if defined(__IPHONE_13_0) || defined(__MAC_10_15)
+#if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             if (display->getFeatures().hasTextureSwizzle.enabled)
             {
                 
@@ -1152,7 +1137,7 @@
                 this->swizzle  = {GL_RED, GL_GREEN, GL_BLUE, GL_ONE};
             }
             else
-#    endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
+#endif  // #if defined(__IPHONE_13_0) || defined(__MAC_10_15)
             {
                 
             this->metalFormat = MTLPixelFormatBC1_RGBA_sRGB;
@@ -1291,6 +1276,394 @@
             this->swizzled = false;
             break;
 
+#elif TARGET_OS_SIMULATOR
+        case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x10_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_10x10_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x10_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x10_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x5_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x5_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_10x5_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x5_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x5_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x6_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x6_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_10x6_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x6_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x6_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x8_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x8_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_10x8_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_10x8_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_10x8_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_10x8_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x10_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_12x10_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_12x10_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x10_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_12x10_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x10_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x12_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_12x12_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_12x12_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_12x12_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_12x12_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_12x12_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_4x4_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_4x4_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_4x4_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_4x4_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_4x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_4x4_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x4_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_5x4_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_5x4_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x4_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_5x4_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x4_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x5_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_5x5_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_5x5_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_5x5_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_5x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_5x5_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x5_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_6x5_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_6x5_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x5_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_6x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x5_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x6_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_6x6_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_6x6_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_6x6_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_6x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_6x6_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x5_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x5_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_8x5_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x5_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x5_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x5_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x6_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x6_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_8x6_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x6_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x6_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x6_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x8_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x8_sRGB;
+            this->actualFormatId = angle::FormatID::ASTC_8x8_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ASTC_8x8_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatASTC_8x8_LDR;
+            this->actualFormatId = angle::FormatID::ASTC_8x8_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::EAC_R11G11_SNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatEAC_RG11Snorm;
+            this->actualFormatId = angle::FormatID::EAC_R11G11_SNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::EAC_R11G11_UNORM_BLOCK:
+
+            this->metalFormat    = MTLPixelFormatEAC_RG11Unorm;
+            this->actualFormatId = angle::FormatID::EAC_R11G11_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::EAC_R11_SNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatEAC_R11Snorm;
+            this->actualFormatId = angle::FormatID::EAC_R11_SNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::EAC_R11_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatEAC_R11Unorm;
+            this->actualFormatId = angle::FormatID::EAC_R11_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC1_R8G8B8_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatETC2_RGB8;
+            this->actualFormatId = angle::FormatID::ETC1_R8G8B8_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8A1_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatETC2_RGB8A1_sRGB;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8A1_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8A1_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatETC2_RGB8A1;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8A1_UNORM_BLOCK;
+            this->initFunction = Initialize4ComponentData<GLubyte, 0x00, 0x00, 0x00, 0xFF>;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8A8_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatEAC_RGBA8_sRGB;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8A8_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8A8_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatEAC_RGBA8;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8A8_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8_SRGB_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatETC2_RGB8_sRGB;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8_SRGB_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::ETC2_R8G8B8_UNORM_BLOCK:
+            
+            this->metalFormat = MTLPixelFormatETC2_RGB8;
+            this->actualFormatId = angle::FormatID::ETC2_R8G8B8_UNORM_BLOCK;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::D24_UNORM_S8_UINT:
+            
+            this->metalFormat = MTLPixelFormatDepth32Float_Stencil8;
+            this->actualFormatId = angle::FormatID::D32_FLOAT_S8X24_UINT;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::R4G4B4A4_UNORM:
+            
+            this->metalFormat = MTLPixelFormatRGBA8Unorm;
+            this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::R5G5B5A1_UNORM:
+            
+            this->metalFormat = MTLPixelFormatRGBA8Unorm;
+            this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
+            this->initFunction = nullptr;
+
+            this->swizzled = false;
+            break;
+
+        case angle::FormatID::R5G6B5_UNORM:
+            
+            this->metalFormat = MTLPixelFormatRGBA8Unorm;
+            this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
+            this->initFunction = Initialize4ComponentData<GLubyte, 0x00, 0x00, 0x00, 0xFF>;
+
+            this->swizzled = false;
+            break;
+
 #endif
 #if TARGET_OS_IOS || TARGET_OS_TV
         case angle::FormatID::ASTC_10x10_SRGB_BLOCK:
@@ -2764,8 +3137,7 @@
             {
                 this->metalFormat = MTLVertexFormatShort4Normalized;
                 this->actualFormatId = angle::FormatID::R16G16B16A16_SNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLshort, 3, 4, std::numeric_limits<GLshort>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLshort, 3, 4, std::numeric_limits<GLshort>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLshort>::max();
                 this->actualSameGLType = true;
             }
@@ -2822,8 +3194,7 @@
             {
                 this->metalFormat = MTLVertexFormatUShort4Normalized;
                 this->actualFormatId = angle::FormatID::R16G16B16A16_UNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLushort, 3, 4, std::numeric_limits<GLushort>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLushort, 3, 4, std::numeric_limits<GLushort>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLushort>::max();
                 this->actualSameGLType = true;
             }
@@ -3213,8 +3584,7 @@
             {
                 this->metalFormat = MTLVertexFormatChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_SNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLbyte, 3, 4, std::numeric_limits<GLbyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLbyte, 3, 4, std::numeric_limits<GLbyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLbyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3271,8 +3641,7 @@
             {
                 this->metalFormat = MTLVertexFormatUChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLubyte, 3, 4, std::numeric_limits<GLubyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLubyte, 3, 4, std::numeric_limits<GLubyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLubyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3329,8 +3698,7 @@
             {
                 this->metalFormat = MTLVertexFormatChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_SNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLbyte, 2, 4, std::numeric_limits<GLbyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLbyte, 2, 4, std::numeric_limits<GLbyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLbyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3387,8 +3755,7 @@
             {
                 this->metalFormat = MTLVertexFormatUChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLubyte, 2, 4, std::numeric_limits<GLubyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLubyte, 2, 4, std::numeric_limits<GLubyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLubyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3445,8 +3812,7 @@
             {
                 this->metalFormat = MTLVertexFormatChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_SNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLbyte, 1, 4, std::numeric_limits<GLbyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLbyte, 1, 4, std::numeric_limits<GLbyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLbyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3503,8 +3869,7 @@
             {
                 this->metalFormat = MTLVertexFormatUChar4Normalized;
                 this->actualFormatId = angle::FormatID::R8G8B8A8_UNORM;
-                this->vertexLoadFunction =
-                    CopyNativeVertexData<GLubyte, 1, 4, std::numeric_limits<GLubyte>::max()>;
+                this->vertexLoadFunction = CopyNativeVertexData<GLubyte, 1, 4, std::numeric_limits<GLubyte>::max()>;
                 this->defaultAlpha = std::numeric_limits<GLubyte>::max();
                 this->actualSameGLType = true;
             }
@@ -3732,9 +4097,7 @@
         default:
             this->metalFormat = MTLVertexFormatInvalid;
             this->actualFormatId = angle::FormatID::NONE;
-            this->vertexLoadFunction = nullptr;
-            this->defaultAlpha       = 0;
-            this->actualSameGLType   = false;
+            this->vertexLoadFunction = nullptr;            this->defaultAlpha = 0;            this->actualSameGLType = false;
     }
 }
 
@@ -3750,18 +4113,11 @@
     bool supportDepthStencilAutoResolve = supportDepthAutoResolve && supportStencilAutoResolve;
 
     // Source: https://developer.apple.com/metal/Metal-Feature-Set-Tables.pdf
-    setFormatCaps(MTLPixelFormatA8Unorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+        setFormatCaps(MTLPixelFormatA8Unorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBGR10A2Unorm, /** filterable*/ true,
-                  /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true,
-                  /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBGR10A2Unorm, /** filterable*/ true, /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBGRA8Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBGRA8Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatBGRA8Unorm_sRGB, /** filterable*/ true,
                   /** writable*/ display->supportsAppleGPUFamily(2), /** blendable*/ true,
@@ -3780,84 +4136,44 @@
                   /** resolve*/ supportDepthStencilAutoResolve, /** colorRenderable*/ false,
                   /** depthRenderable*/ true);
 
-    setFormatCaps(MTLPixelFormatR16Float, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR16Float, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR16Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR16Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR16Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR16Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR16Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR16Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR16Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR16Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatR32Float, /** filterable*/ display->supportsEitherGPUFamily(1, 1),
                   /** writable*/ true, /** blendable*/ true, /** multisample*/ true,
                   /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
                   /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR32Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1),
-                  /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR32Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1), /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR32Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1),
-                  /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR32Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1), /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR8Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR8Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR8Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR8Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR8Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR8Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatR8Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatR8Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG11B10Float, /** filterable*/ true,
-                  /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true,
-                  /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG11B10Float, /** filterable*/ true, /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG16Float, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG16Float, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG16Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG16Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG16Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG16Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG16Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG16Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG16Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG16Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatRG32Float, /** filterable*/ display->supportsEitherGPUFamily(1, 1),
                   /** writable*/ true, /** blendable*/ true,
@@ -3873,32 +4189,17 @@
                   /** blendable*/ false, /** multisample*/ display->supportsEitherGPUFamily(7, 1),
                   /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG8Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG8Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG8Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG8Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG8Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG8Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRG8Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRG8Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGB10A2Uint, /** filterable*/ false,
-                  /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ false,
-                  /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGB10A2Uint, /** filterable*/ false, /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGB10A2Unorm, /** filterable*/ true,
-                  /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true,
-                  /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGB10A2Unorm, /** filterable*/ true, /** writable*/ display->supportsEitherGPUFamily(3, 1), /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatRGB9E5Float, /** filterable*/ true,
                   /** writable*/ display->supportsAppleGPUFamily(3),
@@ -3908,27 +4209,15 @@
                   /** colorRenderable*/ display->supportsAppleGPUFamily(1),
                   /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA16Float, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA16Float, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA16Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA16Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA16Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA16Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA16Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA16Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA16Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA16Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatRGBA32Float,
                   /** filterable*/ display->supportsEitherGPUFamily(1, 1), /** writable*/ true,
@@ -3937,107 +4226,57 @@
                   /** resolve*/ display->supportsMacGPUFamily(1), /** colorRenderable*/ true,
                   /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA32Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1),
-                  /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA32Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1), /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA32Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1),
-                  /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA32Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ display->supportsMacGPUFamily(1), /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA8Sint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA8Sint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA8Snorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true,
-                  /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true,
-                  /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA8Snorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ display->supportsEitherGPUFamily(2, 1), /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA8Uint, /** filterable*/ false, /** writable*/ true,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA8Uint, /** filterable*/ false, /** writable*/ true, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatRGBA8Unorm, /** filterable*/ true, /** writable*/ true,
-                  /** blendable*/ true, /** multisample*/ true, /** resolve*/ true,
-                  /** colorRenderable*/ true, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatRGBA8Unorm, /** filterable*/ true, /** writable*/ true, /** blendable*/ true, /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true, /** depthRenderable*/ false);
 
     setFormatCaps(MTLPixelFormatRGBA8Unorm_sRGB, /** filterable*/ true,
                   /** writable*/ display->supportsAppleGPUFamily(2), /** blendable*/ true,
                   /** multisample*/ true, /** resolve*/ true, /** colorRenderable*/ true,
                   /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatStencil8, /** filterable*/ false, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ true, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ true);
+    setFormatCaps(MTLPixelFormatStencil8, /** filterable*/ false, /** writable*/ false, /** blendable*/ false, /** multisample*/ true, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ true);
 
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
-    setFormatCaps(MTLPixelFormatBC1_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC1_RGBA, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC1_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC1_RGBA_sRGB, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC2_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC2_RGBA, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC2_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC2_RGBA_sRGB, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC3_RGBA, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC3_RGBA, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC3_RGBA_sRGB, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC3_RGBA_sRGB, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC4_RSnorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC4_RSnorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC4_RUnorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC4_RUnorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC5_RGSnorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC5_RGSnorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC5_RGUnorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC5_RGUnorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC6H_RGBFloat, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC6H_RGBFloat, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC6H_RGBUfloat, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC6H_RGBUfloat, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm_sRGB, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ false, /** resolve*/ false,
-                  /** colorRenderable*/ false, /** depthRenderable*/ false);
+    setFormatCaps(MTLPixelFormatBC7_RGBAUnorm_sRGB, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ false, /** resolve*/ false, /** colorRenderable*/ false, /** depthRenderable*/ false);
 
-    setFormatCaps(MTLPixelFormatDepth16Unorm, /** filterable*/ true, /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ true,
-                  /** resolve*/ supportDepthAutoResolve, /** colorRenderable*/ false,
-                  /** depthRenderable*/ true);
+    setFormatCaps(MTLPixelFormatDepth16Unorm, /** filterable*/ true, /** writable*/ false, /** blendable*/ false, /** multisample*/ true, /** resolve*/ supportDepthAutoResolve, /** colorRenderable*/ false, /** depthRenderable*/ true);
 
-    setFormatCaps(MTLPixelFormatDepth24Unorm_Stencil8,
-                  /** filterable*/ display->supportsMacGPUFamily(1), /** writable*/ false,
-                  /** blendable*/ false, /** multisample*/ true,
-                  /** resolve*/ supportDepthStencilAutoResolve, /** colorRenderable*/ false,
-                  /** depthRenderable*/ display->supportsMacGPUFamily(1));
+    setFormatCaps(MTLPixelFormatDepth24Unorm_Stencil8, /** filterable*/ display->supportsMacGPUFamily(1), /** writable*/ false, /** blendable*/ false, /** multisample*/ true, /** resolve*/ supportDepthStencilAutoResolve, /** colorRenderable*/ false, /** depthRenderable*/ display->supportsMacGPUFamily(1));
 
 #endif  // TARGET_OS_OSX || TARGET_OS_MACCATALYST
 #if (TARGET_OS_IOS && !TARGET_OS_MACCATALYST) || TARGET_OS_TV || \
diff --git a/src/libANGLE/renderer/metal/mtl_glslang_mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_glslang_mtl_utils.mm
index b7a7301..1965442 100644
--- a/src/libANGLE/renderer/metal/mtl_glslang_mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_glslang_mtl_utils.mm
@@ -24,7 +24,6 @@
 constexpr size_t ConstStrLen(const char (&)[N])
 {
     static_assert(N > 0, "C++ shouldn't allow N to be zero");
-
     // The length of a string defined as a char array is the size of the array minus 1 (the
     // terminating '\0').
     return N - 1;
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.h b/src/libANGLE/renderer/metal/mtl_render_utils.h
index cfe18f2..3039e07 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.h
@@ -573,17 +573,6 @@ class VertexFormatConversionUtils final : angle::NonCopyable
     RenderPipelineCache mComponentsExpandRenderPipelineCache;
 };
 
-// Util class for handling transform feedback
-class TransformFeedbackUtils
-{
-  public:
-    void onDestroy();
-    AutoObjCPtr<id<MTLRenderPipelineState>> getTransformFeedbackRenderPipeline(
-        ContextMtl *contextMtl,
-        RenderCommandEncoder *cmdEncoder,
-        mtl::RenderPipelineDesc &pipelineDesc);
-};
-
 // RenderUtils: container class of various util classes above
 class RenderUtils : public Context, angle::NonCopyable
 {
diff --git a/src/libANGLE/renderer/metal/mtl_render_utils.mm b/src/libANGLE/renderer/metal/mtl_render_utils.mm
index 1371303..953c371 100644
--- a/src/libANGLE/renderer/metal/mtl_render_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_render_utils.mm
@@ -2553,45 +2553,13 @@ ANGLE_INLINE void SetPipelineState(ComputeCommandEncoder *encoder,
                                             bool sRGBMipmap,
                                             NativeTexLevelArray *mipmapOutputViews)
 {
-    // Only support 3D texture for now.
-    ASSERT(srcTexture->textureType() == MTLTextureType3D);
-
     MTLSize threadGroupSize;
     uint32_t slices                             = 1;
     id<MTLComputePipelineState> computePipeline = nil;
-
-    ensure3DMipGeneratorPipelineInitialized(contextMtl);
-    computePipeline = m3DMipGeneratorPipeline;
-    threadGroupSize =
-        MTLSizeMake(kGenerateMipThreadGroupSizePerDim, kGenerateMipThreadGroupSizePerDim,
-                    kGenerateMipThreadGroupSizePerDim);
-
     // The compute shader supports up to 4 mipmaps generated per pass.
     // See shaders/gen_mipmap.metal
     uint32_t maxMipsPerBatch = 4;
 
-    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
-            computePipeline.maxTotalThreadsPerThreadgroup ||
-        ANGLE_UNLIKELY(
-            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
-    {
-        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
-        // Fallback to generate one mip per pass and reduce thread group size.
-        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
-                           computePipeline.maxTotalThreadsPerThreadgroup))
-        {
-            // Even with reduced thread group size, we cannot proceed.
-            // HACK: use blit command encoder to generate mipmaps if it is not possible
-            // to use compute shader due to hardware limits.
-            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
-            blitEncoder->generateMipmapsForTexture(srcTexture);
-            return angle::Result::Continue;
-        }
-
-        threadGroupSize.depth = 1;
-        maxMipsPerBatch       = 1;
-    }
-
     ComputeCommandEncoder *cmdEncoder = contextMtl->getComputeCommandEncoder();
     ASSERT(cmdEncoder);
 
@@ -2628,13 +2596,33 @@ ANGLE_INLINE void SetPipelineState(ComputeCommandEncoder *encoder,
             UNREACHABLE();
     }
 
-    Generate3DMipmapUniform options;
+    if (threadGroupSize.width * threadGroupSize.height * threadGroupSize.depth >
+            computePipeline.maxTotalThreadsPerThreadgroup ||
+        ANGLE_UNLIKELY(
+            !contextMtl->getDisplay()->getFeatures().allowGenMultipleMipsPerPass.enabled))
+    {
+        // Multiple mipmaps generation is not supported due to hardware's thread group size limits.
+        // Fallback to generate one mip per pass and reduce thread group size.
+        if (ANGLE_UNLIKELY(threadGroupSize.width * threadGroupSize.height >
+                           computePipeline.maxTotalThreadsPerThreadgroup))
+        {
+            // Even with reduced thread group size, we cannot proceed.
+            // HACK: use blit command encoder to generate mipmaps if it is not possible
+            // to use compute shader due to hardware limits.
+            BlitCommandEncoder *blitEncoder = contextMtl->getBlitCommandEncoder();
+            blitEncoder->generateMipmapsForTexture(srcTexture);
+            return angle::Result::Continue;
+        }
 
+        threadGroupSize.depth = 1;
+        maxMipsPerBatch       = 1;
+    }
+
+    Generate3DMipmapUniform options;
     uint32_t remainMips             = srcTexture->mipmapLevels() - 1;
     MipmapNativeLevel batchSrcLevel = kZeroNativeMipLevel;
     options.srcLevel                = batchSrcLevel.get();
     options.sRGB                    = sRGBMipmap;
-
     cmdEncoder->setTexture(srcTexture, 0);
     cmdEncoder->markResourceBeingWrittenByGPU(srcTexture);
     while (remainMips)
diff --git a/src/libANGLE/renderer/metal/mtl_resources.h b/src/libANGLE/renderer/metal/mtl_resources.h
index 175d096..0fc680c 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.h
+++ b/src/libANGLE/renderer/metal/mtl_resources.h
@@ -336,7 +336,9 @@ class Texture final : public Resource,
     TextureRef mReadCopy;
 };
 
-class Buffer final : public Resource, public WrappedObject<id<MTLBuffer>>
+class Buffer final : public Resource,
+                     public WrappedObject<id<MTLBuffer>>,
+                     public std::enable_shared_from_this<Buffer>
 {
   public:
     static angle::Result MakeBuffer(ContextMtl *context,
diff --git a/src/libANGLE/renderer/metal/mtl_resources.mm b/src/libANGLE/renderer/metal/mtl_resources.mm
index 0a470d4..c1d0534 100644
--- a/src/libANGLE/renderer/metal/mtl_resources.mm
+++ b/src/libANGLE/renderer/metal/mtl_resources.mm
@@ -34,12 +34,14 @@ inline NSUInteger GetMipSize(NSUInteger baseSize, const MipmapNativeLevel level)
 // Asynchronously synchronize the content of a resource between GPU memory and its CPU cache.
 // NOTE: This operation doesn't finish immediately upon function's return.
 template <class T>
-void InvokeCPUMemSync(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder, T *resource)
+void InvokeCPUMemSync(ContextMtl *context,
+                      mtl::BlitCommandEncoder *blitEncoder,
+                      const std::shared_ptr<T> &resource)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     if (blitEncoder)
     {
-        blitEncoder->synchronizeResource(resource);
+        blitEncoder->synchronizeResource(resource.get());
 
         resource->resetCPUReadMemNeedSync();
         resource->setCPUReadMemSyncPending(true);
@@ -48,7 +50,7 @@ void InvokeCPUMemSync(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder,
 }
 
 template <class T>
-void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
+void EnsureCPUMemWillBeSynced(ContextMtl *context, const std::shared_ptr<T> &resource)
 {
 #if TARGET_OS_OSX || TARGET_OS_MACCATALYST
     // Make sure GPU & CPU contents are synchronized.
@@ -497,12 +499,12 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
 
 void Texture::syncContent(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder)
 {
-    InvokeCPUMemSync(context, blitEncoder, this);
+    InvokeCPUMemSync(context, blitEncoder, shared_from_this());
 }
 
 void Texture::syncContentIfNeeded(ContextMtl *context)
 {
-    EnsureCPUMemWillBeSynced(context, this);
+    EnsureCPUMemWillBeSynced(context, shared_from_this());
 }
 
 bool Texture::isCPUAccessible() const
@@ -983,7 +985,7 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
 
 void Buffer::syncContent(ContextMtl *context, mtl::BlitCommandEncoder *blitEncoder)
 {
-    InvokeCPUMemSync(context, blitEncoder, this);
+    InvokeCPUMemSync(context, blitEncoder, shared_from_this());
 }
 
 const uint8_t *Buffer::mapReadOnly(ContextMtl *context)
@@ -1004,7 +1006,7 @@ void EnsureCPUMemWillBeSynced(ContextMtl *context, T *resource)
     {
         CommandQueue &cmdQueue = context->cmdQueue();
 
-        EnsureCPUMemWillBeSynced(context, this);
+        EnsureCPUMemWillBeSynced(context, shared_from_this());
 
         if (this->isBeingUsedByGPU(context))
         {
diff --git a/src/libANGLE/renderer/metal/mtl_state_cache.mm b/src/libANGLE/renderer/metal/mtl_state_cache.mm
index 94b275f..8812089 100644
--- a/src/libANGLE/renderer/metal/mtl_state_cache.mm
+++ b/src/libANGLE/renderer/metal/mtl_state_cache.mm
@@ -183,10 +183,10 @@ inline T ToObjC(const T p)
     return textureRef ? textureRef->get() : nil;
 }
 
-void BaseRenderPassAttachmentDescToObjC(const RenderPassAttachmentDesc &src,
-                                        MTLRenderPassAttachmentDescriptor *dst)
+void BaseRenderPassAttachmentDescToObjC(MTLRenderPassAttachmentDescriptor *dst,
+                                        const RenderPassAttachmentDesc &src)
 {
-    const TextureRef &implicitMsTexture = src.implicitMSTexture;
+    auto implicitMsTexture = src.implicitMSTexture;
 
     if (implicitMsTexture)
     {
@@ -232,26 +232,26 @@ void BaseRenderPassAttachmentDescToObjC(const RenderPassAttachmentDesc &src,
     ANGLE_OBJC_CP_PROPERTY(dst, src, storeActionOptions);
 }
 
-void ToObjC(const RenderPassColorAttachmentDesc &desc,
-            MTLRenderPassColorAttachmentDescriptor *objCDesc)
+void ToObjC(MTLRenderPassColorAttachmentDescriptor *objCDesc,
+            const RenderPassColorAttachmentDesc &desc)
 {
-    BaseRenderPassAttachmentDescToObjC(desc, objCDesc);
+    BaseRenderPassAttachmentDescToObjC(objCDesc, desc);
 
     ANGLE_OBJC_CP_PROPERTY(objCDesc, desc, clearColor);
 }
 
-void ToObjC(const RenderPassDepthAttachmentDesc &desc,
-            MTLRenderPassDepthAttachmentDescriptor *objCDesc)
+void ToObjC(MTLRenderPassDepthAttachmentDescriptor *objCDesc,
+            const RenderPassDepthAttachmentDesc &desc)
 {
-    BaseRenderPassAttachmentDescToObjC(desc, objCDesc);
+    BaseRenderPassAttachmentDescToObjC(objCDesc, desc);
 
     ANGLE_OBJC_CP_PROPERTY(objCDesc, desc, clearDepth);
 }
 
-void ToObjC(const RenderPassStencilAttachmentDesc &desc,
-            MTLRenderPassStencilAttachmentDescriptor *objCDesc)
+void ToObjC(MTLRenderPassStencilAttachmentDescriptor *objCDesc,
+            const RenderPassStencilAttachmentDesc &desc)
 {
-    BaseRenderPassAttachmentDescToObjC(desc, objCDesc);
+    BaseRenderPassAttachmentDescToObjC(objCDesc, desc);
 
     ANGLE_OBJC_CP_PROPERTY(objCDesc, desc, clearStencil);
 }
@@ -714,6 +714,30 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
     return loadAction == other.loadAction && storeAction == other.storeAction &&
            storeActionOptions == other.storeActionOptions;
 }
+// Convert to Metal object
+void RenderPassDesc::convertToMetalDesc(MTLRenderPassDescriptor *objCDesc) const
+{
+    ANGLE_MTL_OBJC_SCOPE
+    {
+        for (uint32_t i = 0; i < numColorAttachments; ++i)
+        {
+            ToObjC(objCDesc.colorAttachments[i], colorAttachments[i]);
+        }
+        for (uint32_t i = numColorAttachments; i < kMaxRenderTargets; ++i)
+        {
+            // Inactive render target
+            objCDesc.colorAttachments[i].texture     = nil;
+            objCDesc.colorAttachments[i].level       = 0;
+            objCDesc.colorAttachments[i].slice       = 0;
+            objCDesc.colorAttachments[i].depthPlane  = 0;
+            objCDesc.colorAttachments[i].loadAction  = MTLLoadActionDontCare;
+            objCDesc.colorAttachments[i].storeAction = MTLStoreActionDontCare;
+        }
+
+        ToObjC(objCDesc.depthAttachment, depthAttachment);
+        ToObjC(objCDesc.stencilAttachment, stencilAttachment);
+    }
+}
 
 void RenderPassDesc::populateRenderPipelineOutputDesc(RenderPipelineOutputDesc *outDesc) const
 {
@@ -737,7 +761,7 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
 void RenderPassDesc::populateRenderPipelineOutputDesc(const BlendDescArray &blendDescArray,
                                                       RenderPipelineOutputDesc *outDesc) const
 {
-    RenderPipelineOutputDesc &outputDescriptor = *outDesc;
+    auto &outputDescriptor               = *outDesc;
     outputDescriptor.numColorAttachments = this->numColorAttachments;
     outputDescriptor.sampleCount         = this->sampleCount;
     for (uint32_t i = 0; i < this->numColorAttachments; ++i)
@@ -830,33 +854,9 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
     return depthAttachment == other.depthAttachment && stencilAttachment == other.stencilAttachment;
 }
 
-// Convert to Metal object
-void RenderPassDesc::convertToMetalDesc(MTLRenderPassDescriptor *objCDesc) const
-{
-    ANGLE_MTL_OBJC_SCOPE
-    {
-        for (uint32_t i = 0; i < numColorAttachments; ++i)
-        {
-            ToObjC(colorAttachments[i], objCDesc.colorAttachments[i]);
-        }
-        for (uint32_t i = numColorAttachments; i < kMaxRenderTargets; ++i)
-        {
-            // Inactive render target
-            objCDesc.colorAttachments[i].texture     = nil;
-            objCDesc.colorAttachments[i].level       = 0;
-            objCDesc.colorAttachments[i].slice       = 0;
-            objCDesc.colorAttachments[i].depthPlane  = 0;
-            objCDesc.colorAttachments[i].loadAction  = MTLLoadActionDontCare;
-            objCDesc.colorAttachments[i].storeAction = MTLStoreActionDontCare;
-        }
-
-        ToObjC(depthAttachment, objCDesc.depthAttachment);
-        ToObjC(stencilAttachment, objCDesc.stencilAttachment);
-    }
-}
-
 // RenderPipelineCache implementation
-RenderPipelineCache::RenderPipelineCache() : RenderPipelineCache(nullptr) {}
+RenderPipelineCache::RenderPipelineCache() : RenderPipelineCache(nullptr) {
+}
 
 RenderPipelineCache::RenderPipelineCache(
     RenderPipelineCacheSpecializeShaderFactory *specializedShaderFactory)
@@ -865,7 +865,8 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
 
 RenderPipelineCache::~RenderPipelineCache() {}
 
-void RenderPipelineCache::setVertexShader(Context *context, id<MTLFunction> shader)
+void RenderPipelineCache::setVertexShader(Context *context,
+                                          id<MTLFunction> shader)
 {
     mVertexShader.retainAssign(shader);
 
@@ -878,7 +879,8 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
     recreatePipelineStates(context);
 }
 
-void RenderPipelineCache::setFragmentShader(Context *context, id<MTLFunction> shader)
+void RenderPipelineCache::setFragmentShader(Context *context,
+                                            id<MTLFunction> shader)
 {
     mFragmentShader.retainAssign(shader);
 
@@ -928,10 +930,6 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
 {
     AutoObjCPtr<id<MTLRenderPipelineState>> newState =
         createRenderPipelineState(context, desc, insertDefaultAttribLayout);
-    if (!newState)
-    {
-        return nil;
-    }
 
     int tableIdx = insertDefaultAttribLayout ? 1 : 0;
     auto re      = mRenderPipelineStates[tableIdx].insert(std::make_pair(desc, newState));
@@ -943,6 +941,7 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
     return re.first->second;
 }
 
+
 AutoObjCPtr<id<MTLRenderPipelineState>> RenderPipelineCache::createRenderPipelineState(
     Context *context,
     const RenderPipelineDesc &originalDesc,
@@ -958,7 +957,6 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
             desc.emulateCoverageMask    = false;
             desc.alphaToCoverageEnabled = false;
         }
-
         // Choose shader variant
         id<MTLFunction> vertShader = nil;
         id<MTLFunction> fragShader = nil;
@@ -1003,7 +1001,25 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
 
         // Convert to Objective-C desc:
         AutoObjCObj<MTLRenderPipelineDescriptor> objCDesc = ToObjC(vertShader, fragShader, desc);
-
+        // Validate Render Pipeline State:
+        if (DeviceHasMaximumRenderTargetSize(metalDevice))
+        {
+            NSUInteger maxSize = GetMaxRenderTargetSizeForDeviceInBytes(metalDevice);
+            NSUInteger renderTargetSize =
+                ComputeTotalSizeUsedForMTLRenderPipelineDescriptor(objCDesc, context, metalDevice);
+            if (renderTargetSize > maxSize)
+            {
+                NSString *errorString =
+                    [NSString stringWithFormat:@"This set of render targets requires %lu bytes of "
+                                               @"pixel storage. This device supports %lu bytes.",
+                                               (unsigned long)renderTargetSize, (unsigned long)maxSize];
+                NSError *err = [NSError errorWithDomain:@"MTLValidationError"
+                                                   code:-1
+                                               userInfo:@{NSLocalizedDescriptionKey : errorString}];
+                context->handleError(err, __FILE__, ANGLE_FUNCTION, __LINE__);
+                return nil;
+            }
+        }
         // Special attribute slot for default attribute
         if (insertDefaultAttribLayout)
         {
@@ -1019,15 +1035,15 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
         }
         // Create pipeline state
         NSError *err = nil;
-        id<MTLRenderPipelineState> newState =
-            [metalDevice newRenderPipelineStateWithDescriptor:objCDesc error:&err];
+        auto newState =
+            adoptObjCObj([metalDevice newRenderPipelineStateWithDescriptor:objCDesc error:&err]);
         if (err)
         {
             context->handleError(err, __FILE__, ANGLE_FUNCTION, __LINE__);
             return nil;
         }
 
-        return [newState ANGLE_MTL_AUTORELEASE];
+        return newState;
     }
 }
 
@@ -1182,8 +1198,6 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
         ProvokingVertexComputePipelineDesc desc = originalDesc;
 
         id<MTLFunction> computeFunction = nil;
-        // Special case for transform feedback shader, we've already created it! See
-        // getTransformFeedbackRenderPipeline
         if (mSpecializedShaderFactory &&
             mSpecializedShaderFactory->hasSpecializedShader(gl::ShaderType::Compute, desc))
         {
@@ -1210,15 +1224,15 @@ void ToObjC(const RenderPassStencilAttachmentDesc &desc,
 
         // Convert to Objective-C desc:
         NSError *err = nil;
-        id<MTLComputePipelineState> newState =
-            [metalDevice newComputePipelineStateWithFunction:computeFunction error:&err];
+        auto newState =
+            adoptObjCObj([metalDevice newComputePipelineStateWithFunction:computeFunction error:&err]);
         if (err)
         {
             context->handleError(err, __FILE__, ANGLE_FUNCTION, __LINE__);
             return nil;
         }
 
-        return [newState ANGLE_MTL_AUTORELEASE];
+        return newState;
     }
 }
 
diff --git a/src/libANGLE/renderer/metal/mtl_utils.h b/src/libANGLE/renderer/metal/mtl_utils.h
index 88c219e..e513785 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.h
+++ b/src/libANGLE/renderer/metal/mtl_utils.h
@@ -107,14 +107,12 @@ AutoObjCPtr<id<MTLLibrary>> CreateShaderLibrary(
     bool enableFastMath,
     AutoObjCPtr<NSError *> *error);
 
-AutoObjCPtr<id<MTLLibrary>> CreateShaderLibraryFromBinary(
-    id<MTLDevice> metalDevice,
+AutoObjCPtr<id<MTLLibrary>> CreateShaderLibraryFromBinary(id<MTLDevice> metalDevice,
                                                           const uint8_t *binarySource,
                                                           size_t binarySourceLen,
-    NSDictionary<NSString *, NSObject *> *substitutionDictionary,
                                                           AutoObjCPtr<NSError *> *error);
 
-bool supportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily);
+bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily);
 
 bool SupportsMacGPUFamily(id<MTLDevice> device, uint8_t macFamily);
 
diff --git a/src/libANGLE/renderer/metal/mtl_utils.mm b/src/libANGLE/renderer/metal/mtl_utils.mm
index d70d3f3..13fc975 100644
--- a/src/libANGLE/renderer/metal/mtl_utils.mm
+++ b/src/libANGLE/renderer/metal/mtl_utils.mm
@@ -374,7 +374,13 @@ bool GetCompressedBufferSizeAndRowLengthForTextureWithFormat(const TextureRef &t
     // Intiialize the content to black
     GLint layer, startDepth;
     GetSliceAndDepth(index, &layer, &startDepth);
-    if (texture->isCPUAccessible() && index.getType() != gl::TextureType::_2DMultisample &&
+
+    if (intendedInternalFormat.compressed)
+    {
+        return InitializeCompressedTextureContents(context, texture, textureObjFormat, index, layer,
+                                                   startDepth);
+    }
+    else if (texture->isCPUAccessible() && index.getType() != gl::TextureType::_2DMultisample &&
              index.getType() != gl::TextureType::_2DMultisampleArray && !forceGPUInitialization)
     {
         const angle::Format &dstFormat = angle::Format::Get(textureObjFormat.actualFormatId);
@@ -418,11 +424,6 @@ bool GetCompressedBufferSizeAndRowLengthForTextureWithFormat(const TextureRef &t
             }
         }
     }
-    else if (intendedInternalFormat.compressed)
-    {
-        return InitializeCompressedTextureContents(context, texture, textureObjFormat, index, layer,
-                                                   startDepth);
-    }
     else
     {
         ANGLE_TRY(InitializeTextureContentsGPU(context, texture, textureObjFormat, index,
@@ -1195,11 +1196,11 @@ MTLClearColor EmulatedAlphaClearColor(MTLClearColor color, MTLColorWriteMask col
 
 NSUInteger GetMaxRenderTargetSizeForDeviceInBytes(id<MTLDevice> device)
 {
-    if (supportsAppleGPUFamily(device, 4))
+    if (SupportsAppleGPUFamily(device, 4))
     {
         return 64;
     }
-    else if (supportsAppleGPUFamily(device, 2))
+    else if (SupportsAppleGPUFamily(device, 2))
     {
         return 32;
     }
@@ -1211,7 +1212,7 @@ NSUInteger GetMaxRenderTargetSizeForDeviceInBytes(id<MTLDevice> device)
 
 NSUInteger GetMaxNumberOfRenderTargetsForDevice(id<MTLDevice> device)
 {
-    if (supportsAppleGPUFamily(device, 2) || SupportsMacGPUFamily(device, 1))
+    if (SupportsAppleGPUFamily(device, 2) || SupportsMacGPUFamily(device, 1))
     {
         return 8;
     }
@@ -1223,10 +1224,10 @@ NSUInteger GetMaxNumberOfRenderTargetsForDevice(id<MTLDevice> device)
 
 bool DeviceHasMaximumRenderTargetSize(id<MTLDevice> device)
 {
-    return supportsAppleGPUFamily(device, 1);
+    return SupportsAppleGPUFamily(device, 1);
 }
 
-bool supportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
+bool SupportsAppleGPUFamily(id<MTLDevice> device, uint8_t appleFamily)
 {
 #if (!TARGET_OS_IOS && !TARGET_OS_TV) || TARGET_OS_MACCATALYST
     return false;
diff --git a/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
new file mode 100644
index 0000000..06493d8
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/create_mtl_internal_shaders.py
@@ -0,0 +1,79 @@
+#!/usr/bin/python
+# Copyright 2021 The ANGLE Project Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style license that can be
+# found in the LICENSE file.
+#
+# create_mtl_internal_shaders.py:
+#   Script to compile a metalLib into NSData, for including the compilded
+#       library in the ANGLE dylib.
+
+import os
+import sys
+import json
+from datetime import datetime
+
+sys.path.append('../..')
+
+template_header_boilerplate = """// GENERATED FILE - DO NOT EDIT.
+// Generated by {script_name}
+//
+// Copyright {copyright_year} The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+"""
+
+
+# Convert content of a file to byte array and store in a header file.
+# variable_name: name of C++ variable that will hold the file content as byte array.
+# filename: the file whose content will be converted to C++ byte array.
+# dest_src_file: destination header file that will contain the byte array.
+def append_file_as_byte_array_string(variable_name, filename, dest_src_file):
+    string = '// Generated from {0}:\n'.format(filename)
+    string += 'constexpr uint8_t {0}[]={{\n'.format(variable_name)
+    bytes_ = open(filename, "rb").read()
+    for byte in bytes_:
+        string += '0x{:02x}'.format(byte) + ", "
+    string += "\n};\n"
+    with open(dest_src_file, "a") as out_file:
+        out_file.write(string)
+        
+
+
+# Compile metal shader.
+# compiled_file: The compiled metallib
+# variable_name: name of C++ variable that will hold the compiled binary data as a C array.
+# additional_flags: additional shader compiler flags
+# src_files: metal source files
+def gen_precompiled_shaders(compiled_file, variable_name, output_file):
+    append_file_as_byte_array_string(variable_name,
+                                     compiled_file,
+                                     output_file)
+    os.system('echo "constexpr size_t {0}_len=sizeof({0});" >> \"{1}\"'
+              .format(variable_name, output_file))
+
+def main():
+    input_file = sys.argv[1]
+    output_file = sys.argv[2]
+    os.chdir(sys.path[0])
+    
+    boilerplate_code = template_header_boilerplate.format(
+        script_name=sys.argv[0], copyright_year=datetime.today().year)
+
+    # -------- Compile shaders -----------
+    # boiler plate code
+    os.system("echo \"{0}\" > \"{1}\"".format(boilerplate_code, output_file))
+    os.system(
+        'echo "// Compiled binary for Metal default shaders.\n\n" >>  \"{0}\"'.format(output_file)
+    )
+    os.system('echo "#include <TargetConditionals.h>\n\n" >>  \"{0}\"'.format(output_file))
+
+    os.system('echo "// clang-format off" >> \"{0}\"'.format(output_file))
+    
+    gen_precompiled_shaders(input_file, 'gMetalBinaryShaders', output_file)
+
+    os.system('echo "// clang-format on" >> \"{0}\"'.format(output_file))
+
+
+if __name__ == '__main__':
+    sys.exit(main())
diff --git a/src/libANGLE/renderer/metal/shaders/format_autogen.h b/src/libANGLE/renderer/metal/shaders/format_autogen.h
index abf6a74..af4a353 100644
--- a/src/libANGLE/renderer/metal/shaders/format_autogen.h
+++ b/src/libANGLE/renderer/metal/shaders/format_autogen.h
@@ -246,8 +246,7 @@ enum
     X2R10G10B10_UNORM_VERTEX,
     X2R10G10B10_USCALED_VERTEX
 };
-
 }
 
-}  // namespace mtl_shader
-}  // namespace rx
+}
+}
diff --git a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
index 1818eec..ca3b013 100644
--- a/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
+++ b/src/libANGLE/renderer/metal/shaders/gen_mtl_internal_shaders.py
@@ -61,6 +61,10 @@ def find_clang():
                          'Release+Asserts', 'bin', binary)
 
     if not os.path.isfile(clang):
+        xcrun_clang = subprocess.run(["xcrun", "-f", binary], stdout=subprocess.PIPE, text=True)
+        if xcrun_clang.returncode == 0:
+            clang = xcrun_clang.stdout.strip()
+    if (not os.path.isfile(clang)):
         raise Exception('Cannot find clang')
 
     return clang
@@ -135,6 +139,13 @@ def main():
         out_file.write(')";\n')
         out_file.close()
 
+    with open('mtl_default_shaders_src_autogen.metal', 'wt') as out_file:
+        out_file.write(boilerplate_code)
+        out_file.write('\n')
+        out_file.write('// Metal version of combined Metal default shaders.\n\n')
+        out_file.write(final_combined_src_string.decode("utf-8"))
+        out_file.close()
+
     os.remove(temp_fname)
 
 
diff --git a/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.inc b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.inc
index 9b40f20..821c719 100644
--- a/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.inc
+++ b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.inc
@@ -14,7 +14,7 @@ static char gDefaultMetallibSrc[] = R"(
 # 1 "temp_master_source.metal"
 # 1 "<built-in>" 1
 # 1 "<built-in>" 3
-# 386 "<built-in>" 3
+# 405 "<built-in>" 3
 # 1 "<command line>" 1
 # 1 "<built-in>" 2
 # 1 "temp_master_source.metal" 2
@@ -32,6 +32,7 @@ static char gDefaultMetallibSrc[] = R"(
 # include <metal_stdlib>
 
 
+
 # 1 "./constants.h" 1
 # 11 "./constants.h"
 namespace rx
@@ -1468,6 +1469,7 @@ kernel void generate2DArrayMipmaps(uint lIndex [[thread_index_in_threadgroup]],
 #include <metal_pack>
 
 
+
 # 1 "./format_autogen.h" 1
 # 11 "./format_autogen.h"
 namespace rx
diff --git a/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal
new file mode 100644
index 0000000..9e7aafe
--- /dev/null
+++ b/src/libANGLE/renderer/metal/shaders/mtl_default_shaders_src_autogen.metal
@@ -0,0 +1,3396 @@
+// GENERATED FILE - DO NOT EDIT.
+// Generated by gen_mtl_internal_shaders.py
+//
+// Copyright 2020 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// Metal version of combined Metal default shaders.
+
+# 1 "temp_master_source.metal"
+# 1 "<built-in>" 1
+# 1 "<built-in>" 3
+# 405 "<built-in>" 3
+# 1 "<command line>" 1
+# 1 "<built-in>" 2
+# 1 "temp_master_source.metal" 2
+# 1 "./blit.metal" 1
+
+
+
+
+
+
+
+# 1 "./common.h" 1
+# 13 "./common.h"
+# include <simd/simd.h>
+# include <metal_stdlib>
+
+
+
+# 1 "./constants.h" 1
+# 11 "./constants.h"
+namespace rx
+{
+namespace mtl_shader
+{
+
+enum
+{
+    kTextureType2D = 0,
+    kTextureType2DMultisample = 1,
+    kTextureType2DArray = 2,
+    kTextureTypeCube = 3,
+    kTextureType3D = 4,
+    kTextureTypeCount = 5,
+};
+
+
+
+
+}
+}
+# 18 "./common.h" 2
+
+
+
+
+
+
+
+using namespace metal;
+
+
+
+constant uint32_t kNumColorOutputs [[function_constant(0)]];
+constant bool kColorOutputAvailable0 = kNumColorOutputs > 0;
+constant bool kColorOutputAvailable1 = kNumColorOutputs > 1;
+constant bool kColorOutputAvailable2 = kNumColorOutputs > 2;
+constant bool kColorOutputAvailable3 = kNumColorOutputs > 3;
+
+namespace rx
+{
+namespace mtl_shader
+{
+
+
+constant float2 gCorners[3] = {float2(-1.0f, -1.0f), float2(3.0f, -1.0f), float2(-1.0f, 3.0f)};
+
+template <typename T>
+struct MultipleColorOutputs
+{
+    vec<T, 4> color0 [[color(0), function_constant(kColorOutputAvailable0)]];
+    vec<T, 4> color1 [[color(1), function_constant(kColorOutputAvailable1)]];
+    vec<T, 4> color2 [[color(2), function_constant(kColorOutputAvailable2)]];
+    vec<T, 4> color3 [[color(3), function_constant(kColorOutputAvailable3)]];
+};
+# 61 "./common.h"
+template <typename T>
+static inline MultipleColorOutputs<T> toMultipleColorOutputs(vec<T, 4> color)
+{
+    MultipleColorOutputs<T> re;
+
+    do { if (kColorOutputAvailable0) { re.color0 = color; } } while (0);
+    do { if (kColorOutputAvailable1) { re.color1 = color; } } while (0);
+    do { if (kColorOutputAvailable2) { re.color2 = color; } } while (0);
+    do { if (kColorOutputAvailable3) { re.color3 = color; } } while (0);
+
+    return re;
+}
+
+static inline float3 cubeTexcoords(float2 texcoords, int face)
+{
+    texcoords = 2.0 * texcoords - 1.0;
+    switch (face)
+    {
+        case 0:
+            return float3(1.0, -texcoords.y, -texcoords.x);
+        case 1:
+            return float3(-1.0, -texcoords.y, texcoords.x);
+        case 2:
+            return float3(texcoords.x, 1.0, texcoords.y);
+        case 3:
+            return float3(texcoords.x, -1.0, -texcoords.y);
+        case 4:
+            return float3(texcoords.x, -texcoords.y, 1.0);
+        case 5:
+            return float3(-texcoords.x, -texcoords.y, -1.0);
+    }
+    return float3(texcoords, 0);
+}
+
+template <typename T>
+static inline vec<T, 4> resolveTextureMS(texture2d_ms<T> srcTexture, uint2 coords)
+{
+    uint samples = srcTexture.get_num_samples();
+
+    vec<T, 4> output(0);
+
+    for (uint sample = 0; sample < samples; ++sample)
+    {
+        output += srcTexture.read(coords, sample);
+    }
+
+    output = output / samples;
+
+    return output;
+}
+
+static inline float4 sRGBtoLinear(float4 color)
+{
+    float3 linear1 = color.rgb / 12.92;
+    float3 linear2 = pow((color.rgb + float3(0.055)) / 1.055, 2.4);
+    float3 factor = float3(color.rgb <= float3(0.04045));
+    float4 linear = float4(factor * linear1 + float3(1.0 - factor) * linear2, color.a);
+
+    return linear;
+}
+
+static inline float linearToSRGB(float color)
+{
+    if (color <= 0.0f)
+        return 0.0f;
+    else if (color < 0.0031308f)
+        return 12.92f * color;
+    else if (color < 1.0f)
+        return 1.055f * pow(color, 0.41666f) - 0.055f;
+    else
+        return 1.0f;
+}
+
+static inline float4 linearToSRGB(float4 color)
+{
+    return float4(linearToSRGB(color.r), linearToSRGB(color.g), linearToSRGB(color.b), color.a);
+}
+
+template <typename Short>
+static inline Short bytesToShort(constant uchar *input, uint offset)
+{
+    Short inputLo = input[offset];
+    Short inputHi = input[offset + 1];
+
+    return inputLo | (inputHi << 8);
+}
+
+template <typename Int>
+static inline Int bytesToInt(constant uchar *input, uint offset)
+{
+    Int input0 = input[offset];
+    Int input1 = input[offset + 1];
+    Int input2 = input[offset + 2];
+    Int input3 = input[offset + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+template <typename Short>
+static inline void shortToBytes(Short val, uint offset, device uchar *output)
+{
+    ushort valUnsigned = as_type<ushort>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+}
+
+template <typename Int>
+static inline void intToBytes(Int val, uint offset, device uchar *output)
+{
+    uint valUnsigned = as_type<uint>(val);
+    output[offset] = valUnsigned & 0xff;
+    output[offset + 1] = (valUnsigned >> 8) & 0xff;
+    output[offset + 2] = (valUnsigned >> 16) & 0xff;
+    output[offset + 3] = (valUnsigned >> 24) & 0xff;
+}
+
+static inline void floatToBytes(float val, uint offset, device uchar *output)
+{
+    intToBytes(as_type<uint>(val), offset, output);
+}
+
+static inline void int24bitToBytes(uint val, uint offset, device uchar *output)
+{
+    output[offset] = val & 0xff;
+    output[offset + 1] = (val >> 8) & 0xff;
+    output[offset + 2] = (val >> 16) & 0xff;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T getShiftedData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input >> inputBitStart) & mask;
+}
+
+template <unsigned int inputBitCount, unsigned int inputBitStart, typename T>
+static inline T shiftData(T input)
+{
+    static_assert(inputBitCount + inputBitStart <= (sizeof(T) * 8),
+                  "T must have at least as many bits as inputBitCount + inputBitStart.");
+    const T mask = (1 << inputBitCount) - 1;
+    return (input & mask) << inputBitStart;
+}
+
+template <unsigned int inputBitCount, typename T>
+static inline float normalizedToFloat(T input)
+{
+    static_assert(inputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(inputBitCount <= 23, "Only single precision is supported");
+
+    constexpr float inverseMax = 1.0f / ((1 << inputBitCount) - 1);
+    return input * inverseMax;
+}
+
+template <typename T>
+static inline float normalizedToFloat(T input)
+{
+    return normalizedToFloat<sizeof(T) * 8, T>(input);
+}
+
+template <>
+inline float normalizedToFloat(short input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(int input)
+{
+    constexpr float inverseMax = 1.0f / 0x7fffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <>
+inline float normalizedToFloat(uint input)
+{
+    constexpr float inverseMax = 1.0f / 0xffffffff;
+    return static_cast<float>(input) * inverseMax;
+}
+
+template <unsigned int outputBitCount, typename T>
+static inline T floatToNormalized(float input)
+{
+    static_assert(outputBitCount <= (sizeof(T) * 8),
+                  "T must have more bits than or same bits as inputBitCount.");
+    static_assert(outputBitCount <= 23, "Only single precision is supported");
+
+    return static_cast<T>(((1 << outputBitCount) - 1) * input + 0.5f);
+}
+
+template <typename T>
+static inline T floatToNormalized(float input)
+{
+    return floatToNormalized<sizeof(T) * 8, T>(input);
+}
+
+}
+}
+# 9 "./blit.metal" 2
+
+using namespace rx::mtl_shader;
+
+
+constant bool kPremultiplyAlpha [[function_constant(1)]];
+constant bool kUnmultiplyAlpha [[function_constant(2)]];
+constant int kSourceTextureType [[function_constant(3)]];
+constant int kSourceTexture2Type [[function_constant(4)]];
+
+constant bool kSourceTextureType2D = kSourceTextureType == kTextureType2D;
+constant bool kSourceTextureType2DArray = kSourceTextureType == kTextureType2DArray;
+constant bool kSourceTextureType2DMS = kSourceTextureType == kTextureType2DMultisample;
+constant bool kSourceTextureTypeCube = kSourceTextureType == kTextureTypeCube;
+constant bool kSourceTextureType3D = kSourceTextureType == kTextureType3D;
+
+constant bool kSourceTexture2Type2D = kSourceTexture2Type == kTextureType2D;
+constant bool kSourceTexture2Type2DArray = kSourceTexture2Type == kTextureType2DArray;
+constant bool kSourceTexture2Type2DMS = kSourceTexture2Type == kTextureType2DMultisample;
+constant bool kSourceTexture2TypeCube = kSourceTexture2Type == kTextureTypeCube;
+
+struct BlitParams
+{
+
+    float2 srcTexCoords[3];
+    int srcLevel;
+    int srcLayer;
+    bool dstFlipViewportX;
+    bool dstFlipViewportY;
+    bool dstLuminance;
+    uint8_t padding[13];
+};
+
+struct BlitVSOut
+{
+    float4 position [[position]];
+    float2 texCoords [[user(locn1)]];
+};
+
+vertex BlitVSOut blitVS(unsigned int vid [[vertex_id]], constant BlitParams &options [[buffer(0)]])
+{
+    BlitVSOut output;
+    output.position = float4(gCorners[vid], 0.0, 1.0);
+    output.texCoords = options.srcTexCoords[vid];
+
+    if (options.dstFlipViewportX)
+    {
+        output.position.x = -output.position.x;
+    }
+    if (!options.dstFlipViewportY)
+    {
+
+
+        output.position.y = -output.position.y;
+    }
+
+    return output;
+}
+
+template <typename SrcTexture2d>
+static uint2 getImageCoords(SrcTexture2d srcTexture, float2 texCoords)
+{
+    uint2 dimens(srcTexture.get_width(), srcTexture.get_height());
+    uint2 coords = uint2(texCoords * float2(dimens));
+
+    return coords;
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTextureMS(texture2d_ms<T> srcTexture, float2 texCoords)
+{
+    uint2 coords = getImageCoords(srcTexture, texCoords);
+    return resolveTextureMS(srcTexture, coords);
+}
+
+template <typename T>
+static inline vec<T, 4> blitSampleTexture3D(texture3d<T> srcTexture,
+                                            sampler textureSampler,
+                                            float2 texCoords,
+                                            constant BlitParams &options)
+{
+    uint depth = srcTexture.get_depth(options.srcLevel);
+    float zCoord = (float(options.srcLayer) + 0.5) / float(depth);
+
+    return srcTexture.sample(textureSampler, float3(texCoords, zCoord), level(options.srcLevel));
+}
+# 112 "./blit.metal"
+template <typename T>
+static inline vec<T, 4> blitReadTexture(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output;
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, input.texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, input.texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+            output = blitSampleTextureMS(srcTexture2dMS, input.texCoords);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler,
+                                           cubeTexcoords(input.texCoords, options.srcLayer),
+                                           level(options.srcLevel));
+            break;
+        case kTextureType3D:
+            output = blitSampleTexture3D(srcTexture3d, textureSampler, input.texCoords, options);
+            break;
+    }
+
+    if (kPremultiplyAlpha)
+    {
+        output.xyz *= output.a;
+    }
+    else if (kUnmultiplyAlpha)
+    {
+        if (output.a != 0.0)
+        {
+            output.xyz /= output.a;
+        }
+    }
+
+    if (options.dstLuminance)
+    {
+        output.g = output.b = output.r;
+    }
+
+    return output;
+}
+
+template <typename T>
+static inline MultipleColorOutputs<T> blitFS(BlitVSOut input [[stage_in]], texture2d<T> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<T> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<T> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<T> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<T> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    vec<T, 4> output = blitReadTexture(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+
+    return toMultipleColorOutputs(output);
+}
+
+fragment MultipleColorOutputs<float> blitFloatFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<int> blitIntFS(BlitVSOut input [[stage_in]], texture2d<int> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<int> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<int> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<int> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<int> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+fragment MultipleColorOutputs<uint> blitUIntFS(BlitVSOut input [[stage_in]], texture2d<uint> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<uint> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<uint> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<uint> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<uint> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    return blitFS(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+}
+
+fragment MultipleColorOutputs<uint> copyTextureFloatToUIntFS(BlitVSOut input [[stage_in]], texture2d<float> srcTexture2d [[texture(0), function_constant(kSourceTextureType2D)]], texture2d_array<float> srcTexture2dArray [[texture(0), function_constant(kSourceTextureType2DArray)]], texture2d_ms<float> srcTexture2dMS [[texture(0), function_constant(kSourceTextureType2DMS)]], texturecube<float> srcTextureCube [[texture(0), function_constant(kSourceTextureTypeCube)]], texture3d<float> srcTexture3d [[texture(0), function_constant(kSourceTextureType3D)]], sampler textureSampler [[sampler(0)]], constant BlitParams &options [[buffer(0)]])
+{
+    float4 inputColor = blitReadTexture<>(input, srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube, srcTexture3d, textureSampler, options);
+    uint4 output = uint4(inputColor * float4(255.0));
+
+    return toMultipleColorOutputs(output);
+}
+
+
+struct FragmentDepthOut
+{
+    float depth [[depth(any)]];
+};
+
+static inline float sampleDepth(
+    texture2d<float> srcTexture2d [[function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcTexture2dArray [[function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcTexture2dMS [[function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcTextureCube [[function_constant(kSourceTextureTypeCube)]],
+    float2 texCoords,
+    constant BlitParams &options)
+{
+    float4 output;
+
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTextureType)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(options.srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, options.srcLayer,
+                                              level(options.srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output =
+                srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, options.srcLayer),
+                                      level(options.srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+fragment FragmentDepthOut blitDepthFS(BlitVSOut input [[stage_in]],
+                                      texture2d<float> srcTexture2d
+                                      [[texture(0), function_constant(kSourceTextureType2D)]],
+                                      texture2d_array<float> srcTexture2dArray
+                                      [[texture(0), function_constant(kSourceTextureType2DArray)]],
+                                      texture2d_ms<float> srcTexture2dMS
+                                      [[texture(0), function_constant(kSourceTextureType2DMS)]],
+                                      texturecube<float> srcTextureCube
+                                      [[texture(0), function_constant(kSourceTextureTypeCube)]],
+                                      constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthOut re;
+
+    re.depth = sampleDepth(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                           input.texCoords, options);
+
+    return re;
+}
+
+static inline uint32_t sampleStencil(
+    texture2d<uint32_t> srcTexture2d [[function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray [[function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS [[function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[function_constant(kSourceTexture2TypeCube)]],
+    float2 texCoords,
+    int srcLevel,
+    int srcLayer)
+{
+    uint4 output;
+    constexpr sampler textureSampler(mag_filter::nearest, min_filter::nearest);
+
+    switch (kSourceTexture2Type)
+    {
+        case kTextureType2D:
+            output = srcTexture2d.sample(textureSampler, texCoords, level(srcLevel));
+            break;
+        case kTextureType2DArray:
+            output = srcTexture2dArray.sample(textureSampler, texCoords, srcLayer, level(srcLevel));
+            break;
+        case kTextureType2DMultisample:
+
+            output = srcTexture2dMS.read(getImageCoords(srcTexture2dMS, texCoords), 0);
+            break;
+        case kTextureTypeCube:
+            output = srcTextureCube.sample(textureSampler, cubeTexcoords(texCoords, srcLayer),
+                                           level(srcLevel));
+            break;
+    }
+
+    return output.r;
+}
+
+
+struct BlitStencilToBufferParams
+{
+    float2 srcStartTexCoords;
+    float2 srcTexCoordSteps;
+    int srcLevel;
+    int srcLayer;
+
+    uint2 dstSize;
+    uint dstBufferRowPitch;
+
+    bool resolveMS;
+};
+
+kernel void blitStencilToBufferCS(ushort2 gIndices [[thread_position_in_grid]],
+                                  texture2d<uint32_t> srcTexture2d
+                                  [[texture(1), function_constant(kSourceTexture2Type2D)]],
+                                  texture2d_array<uint32_t> srcTexture2dArray
+                                  [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+                                  texture2d_ms<uint32_t> srcTexture2dMS
+                                  [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+                                  texturecube<uint32_t> srcTextureCube
+                                  [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+                                  constant BlitStencilToBufferParams &options [[buffer(0)]],
+                                  device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.dstSize.x || gIndices.y >= options.dstSize.y)
+    {
+        return;
+    }
+
+    float2 srcTexCoords = options.srcStartTexCoords + float2(gIndices) * options.srcTexCoordSteps;
+
+    if (kSourceTexture2Type == kTextureType2DMultisample && !options.resolveMS)
+    {
+        uint samples = srcTexture2dMS.get_num_samples();
+        uint2 imageCoords = getImageCoords(srcTexture2dMS, srcTexCoords);
+        uint bufferOffset = options.dstBufferRowPitch * gIndices.y + samples * gIndices.x;
+
+        for (uint sample = 0; sample < samples; ++sample)
+        {
+            uint stencilPerSample = srcTexture2dMS.read(imageCoords, sample).r;
+            buffer[bufferOffset + sample] = static_cast<uchar>(stencilPerSample);
+        }
+    }
+    else
+    {
+        uint32_t stencil =
+            sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                          srcTexCoords, options.srcLevel, options.srcLayer);
+
+        buffer[options.dstBufferRowPitch * gIndices.y + gIndices.x] = static_cast<uchar>(stencil);
+    }
+}
+
+
+#if __METAL_VERSION__ >= 210
+
+struct FragmentStencilOut
+{
+    uint32_t stencil [[stencil]];
+};
+
+struct FragmentDepthStencilOut
+{
+    float depth [[depth(any)]];
+    uint32_t stencil [[stencil]];
+};
+
+fragment FragmentStencilOut blitStencilFS(
+    BlitVSOut input [[stage_in]],
+    texture2d<uint32_t> srcTexture2d [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcTextureCube [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentStencilOut re;
+
+    re.stencil = sampleStencil(srcTexture2d, srcTexture2dArray, srcTexture2dMS, srcTextureCube,
+                               input.texCoords, options.srcLevel, options.srcLayer);
+
+    return re;
+}
+
+fragment FragmentDepthStencilOut blitDepthStencilFS(
+    BlitVSOut input [[stage_in]],
+
+    texture2d<float> srcDepthTexture2d [[texture(0), function_constant(kSourceTextureType2D)]],
+    texture2d_array<float> srcDepthTexture2dArray
+    [[texture(0), function_constant(kSourceTextureType2DArray)]],
+    texture2d_ms<float> srcDepthTexture2dMS
+    [[texture(0), function_constant(kSourceTextureType2DMS)]],
+    texturecube<float> srcDepthTextureCube
+    [[texture(0), function_constant(kSourceTextureTypeCube)]],
+
+
+    texture2d<uint32_t> srcStencilTexture2d
+    [[texture(1), function_constant(kSourceTexture2Type2D)]],
+    texture2d_array<uint32_t> srcStencilTexture2dArray
+    [[texture(1), function_constant(kSourceTexture2Type2DArray)]],
+    texture2d_ms<uint32_t> srcStencilTexture2dMS
+    [[texture(1), function_constant(kSourceTexture2Type2DMS)]],
+    texturecube<uint32_t> srcStencilTextureCube
+    [[texture(1), function_constant(kSourceTexture2TypeCube)]],
+
+    constant BlitParams &options [[buffer(0)]])
+{
+    FragmentDepthStencilOut re;
+
+    re.depth = sampleDepth(srcDepthTexture2d, srcDepthTexture2dArray, srcDepthTexture2dMS,
+                           srcDepthTextureCube, input.texCoords, options);
+    re.stencil =
+        sampleStencil(srcStencilTexture2d, srcStencilTexture2dArray, srcStencilTexture2dMS,
+                      srcStencilTextureCube, input.texCoords, options.srcLevel, options.srcLayer);
+    return re;
+}
+#endif
+# 2 "temp_master_source.metal" 2
+# 1 "./clear.metal" 1
+# 10 "./clear.metal"
+using namespace rx::mtl_shader;
+
+struct ClearParams
+{
+    float4 clearColor;
+    float clearDepth;
+};
+
+vertex float4 clearVS(unsigned int vid [[ vertex_id ]],
+                      constant ClearParams &clearParams [[buffer(0)]])
+{
+    return float4(gCorners[vid], clearParams.clearDepth, 1.0);
+}
+
+fragment MultipleColorOutputs<float> clearFloatFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(clearParams.clearColor);
+}
+
+fragment MultipleColorOutputs<int> clearIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<int4>(clearParams.clearColor));
+}
+
+fragment MultipleColorOutputs<uint> clearUIntFS(constant ClearParams &clearParams [[buffer(0)]])
+{
+    return toMultipleColorOutputs(as_type<uint4>(clearParams.clearColor));
+}
+# 3 "temp_master_source.metal" 2
+# 1 "./gen_indices.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+
+
+constant bool kSourceBufferAligned[[function_constant(100)]];
+constant bool kSourceIndexIsU8[[function_constant(200)]];
+constant bool kSourceIndexIsU16[[function_constant(300)]];
+constant bool kSourceIndexIsU32[[function_constant(400)]];
+constant bool kSourceBufferUnaligned = !kSourceBufferAligned;
+constant bool kUseSourceBufferU8 = kSourceIndexIsU8 || kSourceBufferUnaligned;
+constant bool kUseSourceBufferU16 = kSourceIndexIsU16 && kSourceBufferAligned;
+constant bool kUseSourceBufferU32 = kSourceIndexIsU32 && kSourceBufferAligned;
+
+struct IndexConversionParams
+{
+    uint32_t srcOffset;
+    uint32_t indexCount;
+    bool primitiveRestartEnabled;
+};
+
+
+
+inline ushort getIndexAligned(constant ushort *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 2 + idx];
+}
+inline uint getIndexAligned(constant uint *inputAligned, uint offset, uint idx)
+{
+    return inputAligned[offset / 4 + idx];
+}
+inline uchar getIndexAligned(constant uchar *input, uint offset, uint idx)
+{
+    return input[offset + idx];
+}
+inline ushort getIndexUnalignedU16(constant uchar *input, uint offset, uint idx)
+{
+    ushort inputLo = input[offset + 2 * idx];
+    ushort inputHi = input[offset + 2 * idx + 1];
+
+    return inputLo | (inputHi << 8);
+}
+inline uint getIndexUnalignedU32(constant uchar *input, uint offset, uint idx)
+{
+    uint input0 = input[offset + 4 * idx];
+    uint input1 = input[offset + 4 * idx + 1];
+    uint input2 = input[offset + 4 * idx + 2];
+    uint input3 = input[offset + 4 * idx + 3];
+
+    return input0 | (input1 << 8) | (input2 << 16) | (input3 << 24);
+}
+
+kernel void convertIndexU8ToU16(uint idx [[thread_position_in_grid]],
+                                constant IndexConversionParams &options [[buffer(0)]],
+                                constant uchar *input [[buffer(1)]],
+                                device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uchar value = getIndexAligned(input, options.srcOffset, idx);
+
+    if (options.primitiveRestartEnabled && value == 0xff)
+    {
+        output[idx] = 0xffff;
+    }
+    else
+    {
+        output[idx] = value;
+    }
+}
+
+kernel void convertIndexU16(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant ushort *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device ushort *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    ushort value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU16(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+kernel void convertIndexU32(uint idx [[thread_position_in_grid]],
+                            constant IndexConversionParams &options [[buffer(0)]],
+                            constant uchar *input
+                            [[buffer(1), function_constant(kSourceBufferUnaligned)]],
+                            constant uint *inputAligned
+                            [[buffer(1), function_constant(kSourceBufferAligned)]],
+                            device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint value;
+    if (kSourceBufferAligned)
+    {
+        value = getIndexAligned(inputAligned, options.srcOffset, idx);
+    }
+    else
+    {
+        value = getIndexUnalignedU32(input, options.srcOffset, idx);
+    }
+    output[idx] = value;
+}
+
+struct IndexFromArrayParams
+{
+    uint firstVertex;
+
+    uint vertexCount;
+};
+
+
+kernel void genTriFanIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                      constant IndexFromArrayParams &options [[buffer(0)]],
+                                      device uint *output [[buffer(2)]])
+{
+    if (idx >= options.vertexCount) { return; };
+
+    uint vertexIdx = options.firstVertex + 2 + idx;
+
+    output[3 * idx] = options.firstVertex;
+    output[3 * idx + 1] = vertexIdx - 1;
+    output[3 * idx + 2] = vertexIdx;
+}
+
+inline uint getIndexU32(uint offset,
+                        uint idx,
+                        constant uchar *inputU8 [[function_constant(kUseSourceBufferU8)]],
+                        constant ushort *inputU16 [[function_constant(kUseSourceBufferU16)]],
+                        constant uint *inputU32 [[function_constant(kUseSourceBufferU32)]])
+{
+    if (kUseSourceBufferU8)
+    {
+        if (kSourceIndexIsU16)
+        {
+            return getIndexUnalignedU16(inputU8, offset, idx);
+        }
+        else if (kSourceIndexIsU32)
+        {
+            return getIndexUnalignedU32(inputU8, offset, idx);
+        }
+        return getIndexAligned(inputU8, offset, idx);
+    }
+    else if (kUseSourceBufferU16)
+    {
+        return getIndexAligned(inputU16, offset, idx);
+    }
+    else if (kUseSourceBufferU32)
+    {
+        return getIndexAligned(inputU32, offset, idx);
+    }
+    return 0;
+}
+
+
+
+
+kernel void genTriFanIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                         constant IndexConversionParams &options [[buffer(0)]],
+                                         constant uchar *inputU8
+                                         [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                         constant ushort *inputU16
+                                         [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                         constant uint *inputU32
+                                         [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                         device uint *output [[buffer(2)]])
+{
+    if (idx >= options.indexCount) { return; };
+
+    uint elemIdx = 2 + idx;
+
+    output[3 * idx] = getIndexU32(options.srcOffset, 0, inputU8, inputU16, inputU32);
+    output[3 * idx + 1] = getIndexU32(options.srcOffset, elemIdx - 1, inputU8, inputU16, inputU32);
+    output[3 * idx + 2] = getIndexU32(options.srcOffset, elemIdx, inputU8, inputU16, inputU32);
+}
+
+
+kernel void genLineLoopIndicesFromArray(uint idx [[thread_position_in_grid]],
+                                        constant IndexFromArrayParams &options [[buffer(0)]],
+                                        device uint *output [[buffer(2)]])
+{
+    uint totalIndices = options.vertexCount + 1;
+    if (idx >= totalIndices) { return; };
+
+    output[idx] = options.firstVertex + idx % options.vertexCount;
+}
+
+
+
+kernel void genLineLoopIndicesFromElements(uint idx [[thread_position_in_grid]],
+                                           constant IndexConversionParams &options [[buffer(0)]],
+                                           constant uchar *inputU8
+                                           [[buffer(1), function_constant(kUseSourceBufferU8)]],
+                                           constant ushort *inputU16
+                                           [[buffer(1), function_constant(kUseSourceBufferU16)]],
+                                           constant uint *inputU32
+                                           [[buffer(1), function_constant(kUseSourceBufferU32)]],
+                                           device uint *output [[buffer(2)]])
+{
+    uint totalTargetIndices = options.indexCount + 1;
+    if (idx >= totalTargetIndices) { return; };
+
+    output[idx] =
+        getIndexU32(options.srcOffset, idx % options.indexCount, inputU8, inputU16, inputU32);
+}
+# 4 "temp_master_source.metal" 2
+# 1 "./gen_mipmap.metal" 1
+
+
+
+
+
+
+
+
+using namespace rx::mtl_shader;
+# 31 "./gen_mipmap.metal"
+struct GenMipParams
+{
+    uint srcLevel;
+    uint numMipLevelsToGen;
+    bool sRGB;
+};
+
+
+
+kernel void generate3DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort3 gIndices [[thread_position_in_grid]],
+                              texture3d<float> srcTexture [[texture(0)]],
+                              texture3d<float, access::write> dstMip1 [[texture(1)]],
+                              texture3d<float, access::write> dstMip2 [[texture(2)]],
+                              texture3d<float, access::write> dstMip3 [[texture(3)]],
+                              texture3d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    ushort3 mipSize = ushort3(dstMip1.get_width(), dstMip1.get_height(), dstMip1.get_depth());
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y && gIndices.z < mipSize.z;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8 * 8)];
+    threadgroup float sG[(8 * 8 * 8)];
+    threadgroup float sB[(8 * 8 * 8)];
+    threadgroup float sA[(8 * 8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float3 texCoords = (float3(gIndices) + float3(0.5, 0.5, 0.5)) / float3(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write(texel1, gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    if (options.sRGB)
+    {
+        texel1 = linearToSRGB(texel1);
+    }
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x49) == 0)
+    {
+        bool3 atEdge = gIndices == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.z) ? (texel1) : (float4(sR[lIndex + (8 * 8)], sG[lIndex + (8 * 8)], sB[lIndex + (8 * 8)], sA[lIndex + (8 * 8)]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + ((8 * 8) + 1)], sG[lIndex + ((8 * 8) + 1)], sB[lIndex + ((8 * 8) + 1)], sA[lIndex + ((8 * 8) + 1)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + ((8 * 8) + 8)], sG[lIndex + ((8 * 8) + 8)], sB[lIndex + ((8 * 8) + 8)], sA[lIndex + ((8 * 8) + 8)]));
+
+
+        float4 texel8 =
+            (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + ((8 * 8) + 8 + 1)], sG[lIndex + ((8 * 8) + 8 + 1)], sB[lIndex + ((8 * 8) + 8 + 1)], sA[lIndex + ((8 * 8) + 8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0xdb) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 1) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (2 * 8)], sG[lIndex + (2 * 8)], sB[lIndex + (2 * 8)], sA[lIndex + (2 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (2 * (8 * 8))], sG[lIndex + (2 * (8 * 8))], sB[lIndex + (2 * (8 * 8))], sA[lIndex + (2 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (2 * (8 * 8) + 2)], sG[lIndex + (2 * (8 * 8) + 2)], sB[lIndex + (2 * (8 * 8) + 2)], sA[lIndex + (2 * (8 * 8) + 2)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8)], sG[lIndex + (2 * (8 * 8) + 2 * 8)], sB[lIndex + (2 * (8 * 8) + 2 * 8)], sA[lIndex + (2 * (8 * 8) + 2 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sG[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sB[lIndex + (2 * (8 * 8) + 2 * 8 + 2)], sA[lIndex + (2 * (8 * 8) + 2 * 8 + 2)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1ff) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort3(1));
+        bool3 atEdge = (gIndices >> 2) == (mipSize - ushort3(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + (4 * 8)], sG[lIndex + (4 * 8)], sB[lIndex + (4 * 8)], sA[lIndex + (4 * 8)]));
+
+        float4 texel4 =
+            (atEdge.z) ? (texel1) : (float4(sR[lIndex + (4 * (8 * 8))], sG[lIndex + (4 * (8 * 8))], sB[lIndex + (4 * (8 * 8))], sA[lIndex + (4 * (8 * 8))]));
+
+        float4 texel5 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        float4 texel6 = (atEdge.x | atEdge.z) ? (texel2) : (float4(sR[lIndex + (4 * (8 * 8) + 4)], sG[lIndex + (4 * (8 * 8) + 4)], sB[lIndex + (4 * (8 * 8) + 4)], sA[lIndex + (4 * (8 * 8) + 4)]));
+
+
+        float4 texel7 = (atEdge.y | atEdge.z) ? (texel3) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8)], sG[lIndex + (4 * (8 * 8) + 4 * 8)], sB[lIndex + (4 * (8 * 8) + 4 * 8)], sA[lIndex + (4 * (8 * 8) + 4 * 8)]));
+
+
+
+        float4 texel8 = (atEdge.x | atEdge.y | atEdge.z) ? (texel5) : (float4(sR[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sG[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sB[lIndex + (4 * (8 * 8) + 4 * 8 + 4)], sA[lIndex + (4 * (8 * 8) + 4 * 8 + 4)]));
+
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4 + texel5 + texel6 + texel7 + texel8) / 8.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+kernel void generate2DMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                              ushort2 gIndices [[thread_position_in_grid]],
+                              texture2d<float> srcTexture [[texture(0)]],
+                              texture2d<float, access::write> dstMip1 [[texture(1)]],
+                              texture2d<float, access::write> dstMip2 [[texture(2)]],
+                              texture2d<float, access::write> dstMip3 [[texture(3)]],
+                              texture2d<float, access::write> dstMip4 [[texture(4)]],
+                              constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mipSize =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mipSize.x && gIndices.y < mipSize.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+
+    float4 texel1;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices) + float2(0.5, 0.5)) / float2(mipSize);
+        texel1 = srcTexture.sample(textureSampler, texCoords, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 1);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 2);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices >> 3);
+    }
+}
+
+template <typename TextureTypeR, typename TextureTypeW>
+static __attribute__((always_inline)) void generateCubeOr2DArray2ndAndMoreMipmaps(
+    uint lIndex,
+    ushort3 gIndices,
+    TextureTypeR srcTexture,
+    TextureTypeW dstMip2,
+    TextureTypeW dstMip3,
+    TextureTypeW dstMip4,
+    ushort2 mip1Size,
+    float4 mip1Texel,
+    threadgroup float *sR,
+    threadgroup float *sG,
+    threadgroup float *sB,
+    threadgroup float *sA,
+    constant GenMipParams &options)
+{
+    ushort2 mipSize = mip1Size;
+    float4 texel1 = mip1Texel;
+
+
+
+
+    sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x09) == 0)
+    {
+        bool2 atEdge = gIndices.xy == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 1], sG[lIndex + 1], sB[lIndex + 1], sA[lIndex + 1]));
+
+        float4 texel3 = (atEdge.y) ? (texel1) : (float4(sR[lIndex + 8], sG[lIndex + 8], sB[lIndex + 8], sA[lIndex + 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (8 + 1)], sG[lIndex + (8 + 1)], sB[lIndex + (8 + 1)], sA[lIndex + (8 + 1)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip2.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 1, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 2)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x1b) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 1) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 2], sG[lIndex + 2], sB[lIndex + 2], sA[lIndex + 2]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 2 * 8], sG[lIndex + 2 * 8], sB[lIndex + 2 * 8], sA[lIndex + 2 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (2 * 8 + 2)], sG[lIndex + (2 * 8 + 2)], sB[lIndex + (2 * 8 + 2)], sA[lIndex + (2 * 8 + 2)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip3.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 2, gIndices.z);
+
+
+        sR[lIndex] = texel1.r; sG[lIndex] = texel1.g; sB[lIndex] = texel1.b; sA[lIndex] = texel1.a;;
+    }
+
+    if (options.numMipLevelsToGen == 3)
+    {
+        return;
+    }
+
+
+    threadgroup_barrier(mem_flags::mem_threadgroup);
+
+
+    if ((lIndex & 0x3f) == 0)
+    {
+        mipSize = max(mipSize >> 1, ushort2(1));
+        bool2 atEdge = (gIndices.xy >> 2) == (mipSize - ushort2(1));
+
+
+
+        float4 texel2 = (atEdge.x) ? (texel1) : (float4(sR[lIndex + 4], sG[lIndex + 4], sB[lIndex + 4], sA[lIndex + 4]));
+
+        float4 texel3 =
+            (atEdge.y) ? (texel1) : (float4(sR[lIndex + 4 * 8], sG[lIndex + 4 * 8], sB[lIndex + 4 * 8], sA[lIndex + 4 * 8]));
+
+        float4 texel4 = (atEdge.x | atEdge.y) ? (texel2) : (float4(sR[lIndex + (4 * 8 + 4)], sG[lIndex + (4 * 8 + 4)], sB[lIndex + (4 * 8 + 4)], sA[lIndex + (4 * 8 + 4)]));
+
+
+        texel1 = (texel1 + texel2 + texel3 + texel4) / 4.0;
+
+        dstMip4.write((options.sRGB ? sRGBtoLinear(texel1) : texel1), gIndices.xy >> 3, gIndices.z);
+    }
+}
+
+kernel void generateCubeMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                ushort3 gIndices [[thread_position_in_grid]],
+                                texturecube<float> srcTexture [[texture(0)]],
+                                texturecube<float, access::write> dstMip1 [[texture(1)]],
+                                texturecube<float, access::write> dstMip2 [[texture(2)]],
+                                texturecube<float, access::write> dstMip3 [[texture(3)]],
+                                texturecube<float, access::write> dstMip4 [[texture(4)]],
+                                constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel = srcTexture.sample(textureSampler, cubeTexcoords(texCoords, int(gIndices.z)),
+                                      level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+
+kernel void generate2DArrayMipmaps(uint lIndex [[thread_index_in_threadgroup]],
+                                   ushort3 gIndices [[thread_position_in_grid]],
+                                   texture2d_array<float> srcTexture [[texture(0)]],
+                                   texture2d_array<float, access::write> dstMip1 [[texture(1)]],
+                                   texture2d_array<float, access::write> dstMip2 [[texture(2)]],
+                                   texture2d_array<float, access::write> dstMip3 [[texture(3)]],
+                                   texture2d_array<float, access::write> dstMip4 [[texture(4)]],
+                                   constant GenMipParams &options [[buffer(0)]])
+{
+    uint firstMipLevel = options.srcLevel + 1;
+    ushort2 mip1Size =
+        ushort2(srcTexture.get_width(firstMipLevel), srcTexture.get_height(firstMipLevel));
+    bool validThread = gIndices.x < mip1Size.x && gIndices.y < mip1Size.y;
+
+    constexpr sampler textureSampler(mag_filter::linear, min_filter::linear, mip_filter::linear);
+
+
+    float4 mip1Texel;
+    if (validThread)
+    {
+        float2 texCoords = (float2(gIndices.xy) + float2(0.5, 0.5)) / float2(mip1Size);
+        mip1Texel =
+            srcTexture.sample(textureSampler, texCoords, gIndices.z, level(options.srcLevel));
+
+
+        dstMip1.write((options.sRGB ? sRGBtoLinear(mip1Texel) : mip1Texel), gIndices.xy, gIndices.z);
+    }
+    else
+    {
+
+        lIndex = 0xffffffff;
+    }
+
+    if (options.numMipLevelsToGen == 1)
+    {
+        return;
+    }
+
+
+    threadgroup float sR[(8 * 8)];
+    threadgroup float sG[(8 * 8)];
+    threadgroup float sB[(8 * 8)];
+    threadgroup float sA[(8 * 8)];
+
+    generateCubeOr2DArray2ndAndMoreMipmaps(lIndex, gIndices, srcTexture, dstMip2, dstMip3, dstMip4,
+                                           mip1Size, mip1Texel, sR, sG, sB, sA, options);
+}
+# 5 "temp_master_source.metal" 2
+# 1 "./copy_buffer.metal" 1
+# 12 "./copy_buffer.metal"
+#include <metal_pack>
+
+
+
+# 1 "./format_autogen.h" 1
+# 11 "./format_autogen.h"
+namespace rx
+{
+namespace mtl_shader
+{
+
+namespace FormatID
+{
+enum
+{
+    NONE,
+    D16_UNORM,
+    D24_UNORM_S8_UINT,
+    D24_UNORM_X8_UINT,
+    D32_FLOAT,
+    D32_FLOAT_S8X24_UINT,
+    D32_UNORM,
+    S8_UINT,
+    A16_FLOAT,
+    A1R5G5B5_UNORM,
+    A2R10G10B10_SINT_VERTEX,
+    A2R10G10B10_SNORM_VERTEX,
+    A2R10G10B10_SSCALED_VERTEX,
+    A2R10G10B10_UINT_VERTEX,
+    A2R10G10B10_UNORM_VERTEX,
+    A2R10G10B10_USCALED_VERTEX,
+    A32_FLOAT,
+    A8_UNORM,
+    ASTC_10x10_SRGB_BLOCK,
+    ASTC_10x10_UNORM_BLOCK,
+    ASTC_10x5_SRGB_BLOCK,
+    ASTC_10x5_UNORM_BLOCK,
+    ASTC_10x6_SRGB_BLOCK,
+    ASTC_10x6_UNORM_BLOCK,
+    ASTC_10x8_SRGB_BLOCK,
+    ASTC_10x8_UNORM_BLOCK,
+    ASTC_12x10_SRGB_BLOCK,
+    ASTC_12x10_UNORM_BLOCK,
+    ASTC_12x12_SRGB_BLOCK,
+    ASTC_12x12_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_BLOCK,
+    ASTC_3x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x3x3_UNORM_BLOCK,
+    ASTC_4x3x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4_SRGB_BLOCK,
+    ASTC_4x4_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_BLOCK,
+    ASTC_4x4x3_UNORM_SRGB_BLOCK,
+    ASTC_4x4x4_UNORM_BLOCK,
+    ASTC_4x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x4_SRGB_BLOCK,
+    ASTC_5x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_BLOCK,
+    ASTC_5x4x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5_SRGB_BLOCK,
+    ASTC_5x5_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_BLOCK,
+    ASTC_5x5x4_UNORM_SRGB_BLOCK,
+    ASTC_5x5x5_UNORM_BLOCK,
+    ASTC_5x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x5_SRGB_BLOCK,
+    ASTC_6x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_BLOCK,
+    ASTC_6x5x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6_SRGB_BLOCK,
+    ASTC_6x6_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_BLOCK,
+    ASTC_6x6x5_UNORM_SRGB_BLOCK,
+    ASTC_6x6x6_UNORM_BLOCK,
+    ASTC_6x6x6_UNORM_SRGB_BLOCK,
+    ASTC_8x5_SRGB_BLOCK,
+    ASTC_8x5_UNORM_BLOCK,
+    ASTC_8x6_SRGB_BLOCK,
+    ASTC_8x6_UNORM_BLOCK,
+    ASTC_8x8_SRGB_BLOCK,
+    ASTC_8x8_UNORM_BLOCK,
+    B10G10R10A2_UNORM,
+    B4G4R4A4_UNORM,
+    B5G5R5A1_UNORM,
+    B5G6R5_UNORM,
+    B8G8R8A8_TYPELESS,
+    B8G8R8A8_TYPELESS_SRGB,
+    B8G8R8A8_UNORM,
+    B8G8R8A8_UNORM_SRGB,
+    B8G8R8X8_UNORM,
+    BC1_RGBA_UNORM_BLOCK,
+    BC1_RGBA_UNORM_SRGB_BLOCK,
+    BC1_RGB_UNORM_BLOCK,
+    BC1_RGB_UNORM_SRGB_BLOCK,
+    BC2_RGBA_UNORM_BLOCK,
+    BC2_RGBA_UNORM_SRGB_BLOCK,
+    BC3_RGBA_UNORM_BLOCK,
+    BC3_RGBA_UNORM_SRGB_BLOCK,
+    BC4_RED_SNORM_BLOCK,
+    BC4_RED_UNORM_BLOCK,
+    BC5_RG_SNORM_BLOCK,
+    BC5_RG_UNORM_BLOCK,
+    BC6H_RGB_SFLOAT_BLOCK,
+    BC6H_RGB_UFLOAT_BLOCK,
+    BC7_RGBA_UNORM_BLOCK,
+    BC7_RGBA_UNORM_SRGB_BLOCK,
+    EAC_R11G11_SNORM_BLOCK,
+    EAC_R11G11_UNORM_BLOCK,
+    EAC_R11_SNORM_BLOCK,
+    EAC_R11_UNORM_BLOCK,
+    ETC1_LOSSY_DECODE_R8G8B8_UNORM_BLOCK,
+    ETC1_R8G8B8_UNORM_BLOCK,
+    ETC2_R8G8B8A1_SRGB_BLOCK,
+    ETC2_R8G8B8A1_UNORM_BLOCK,
+    ETC2_R8G8B8A8_SRGB_BLOCK,
+    ETC2_R8G8B8A8_UNORM_BLOCK,
+    ETC2_R8G8B8_SRGB_BLOCK,
+    ETC2_R8G8B8_UNORM_BLOCK,
+    G8_B8R8_2PLANE_420_UNORM,
+    G8_B8_R8_3PLANE_420_UNORM,
+    L16A16_FLOAT,
+    L16_FLOAT,
+    L32A32_FLOAT,
+    L32_FLOAT,
+    L8A8_UNORM,
+    L8_UNORM,
+    PVRTC1_RGBA_2BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_BLOCK,
+    PVRTC1_RGBA_4BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_BLOCK,
+    PVRTC1_RGB_2BPP_UNORM_SRGB_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_BLOCK,
+    PVRTC1_RGB_4BPP_UNORM_SRGB_BLOCK,
+    R10G10B10A2_SINT,
+    R10G10B10A2_SNORM,
+    R10G10B10A2_SSCALED,
+    R10G10B10A2_UINT,
+    R10G10B10A2_UNORM,
+    R10G10B10A2_USCALED,
+    R10G10B10X2_UNORM,
+    R11G11B10_FLOAT,
+    R16G16B16A16_FLOAT,
+    R16G16B16A16_SINT,
+    R16G16B16A16_SNORM,
+    R16G16B16A16_SSCALED,
+    R16G16B16A16_UINT,
+    R16G16B16A16_UNORM,
+    R16G16B16A16_USCALED,
+    R16G16B16_FLOAT,
+    R16G16B16_SINT,
+    R16G16B16_SNORM,
+    R16G16B16_SSCALED,
+    R16G16B16_UINT,
+    R16G16B16_UNORM,
+    R16G16B16_USCALED,
+    R16G16_FLOAT,
+    R16G16_SINT,
+    R16G16_SNORM,
+    R16G16_SSCALED,
+    R16G16_UINT,
+    R16G16_UNORM,
+    R16G16_USCALED,
+    R16_FLOAT,
+    R16_SINT,
+    R16_SNORM,
+    R16_SSCALED,
+    R16_UINT,
+    R16_UNORM,
+    R16_USCALED,
+    R32G32B32A32_FIXED,
+    R32G32B32A32_FLOAT,
+    R32G32B32A32_SINT,
+    R32G32B32A32_SNORM,
+    R32G32B32A32_SSCALED,
+    R32G32B32A32_UINT,
+    R32G32B32A32_UNORM,
+    R32G32B32A32_USCALED,
+    R32G32B32_FIXED,
+    R32G32B32_FLOAT,
+    R32G32B32_SINT,
+    R32G32B32_SNORM,
+    R32G32B32_SSCALED,
+    R32G32B32_UINT,
+    R32G32B32_UNORM,
+    R32G32B32_USCALED,
+    R32G32_FIXED,
+    R32G32_FLOAT,
+    R32G32_SINT,
+    R32G32_SNORM,
+    R32G32_SSCALED,
+    R32G32_UINT,
+    R32G32_UNORM,
+    R32G32_USCALED,
+    R32_FIXED,
+    R32_FLOAT,
+    R32_SINT,
+    R32_SNORM,
+    R32_SSCALED,
+    R32_UINT,
+    R32_UNORM,
+    R32_USCALED,
+    R4G4B4A4_UNORM,
+    R5G5B5A1_UNORM,
+    R5G6B5_UNORM,
+    R8G8B8A8_SINT,
+    R8G8B8A8_SNORM,
+    R8G8B8A8_SSCALED,
+    R8G8B8A8_TYPELESS,
+    R8G8B8A8_TYPELESS_SRGB,
+    R8G8B8A8_UINT,
+    R8G8B8A8_UNORM,
+    R8G8B8A8_UNORM_SRGB,
+    R8G8B8A8_USCALED,
+    R8G8B8X8_UNORM,
+    R8G8B8_SINT,
+    R8G8B8_SNORM,
+    R8G8B8_SSCALED,
+    R8G8B8_UINT,
+    R8G8B8_UNORM,
+    R8G8B8_UNORM_SRGB,
+    R8G8B8_USCALED,
+    R8G8_SINT,
+    R8G8_SNORM,
+    R8G8_SSCALED,
+    R8G8_UINT,
+    R8G8_UNORM,
+    R8G8_UNORM_SRGB,
+    R8G8_USCALED,
+    R8_SINT,
+    R8_SNORM,
+    R8_SSCALED,
+    R8_UINT,
+    R8_UNORM,
+    R8_UNORM_SRGB,
+    R8_USCALED,
+    R9G9B9E5_SHAREDEXP,
+    X2R10G10B10_SINT_VERTEX,
+    X2R10G10B10_SNORM_VERTEX,
+    X2R10G10B10_SSCALED_VERTEX,
+    X2R10G10B10_UINT_VERTEX,
+    X2R10G10B10_UNORM_VERTEX,
+    X2R10G10B10_USCALED_VERTEX
+};
+
+}
+
+}
+}
+# 16 "./copy_buffer.metal" 2
+
+using namespace rx::mtl_shader;
+
+constant int kCopyFormatType [[function_constant(10)]];
+
+
+constant int kCopyTextureType [[function_constant(20)]];
+constant bool kCopyTextureType2D = kCopyTextureType == kTextureType2D;
+constant bool kCopyTextureType2DArray = kCopyTextureType == kTextureType2DArray;
+constant bool kCopyTextureType2DMS = kCopyTextureType == kTextureType2DMultisample;
+constant bool kCopyTextureTypeCube = kCopyTextureType == kTextureTypeCube;
+constant bool kCopyTextureType3D = kCopyTextureType == kTextureType3D;
+
+struct CopyPixelParams
+{
+    uint3 copySize;
+    uint3 textureOffset;
+
+    uint bufferStartOffset;
+    uint pixelSize;
+    uint bufferRowPitch;
+    uint bufferDepthPitch;
+};
+
+struct WritePixelParams
+{
+    uint2 copySize;
+    uint2 textureOffset;
+
+    uint bufferStartOffset;
+
+    uint pixelSize;
+    uint bufferRowPitch;
+
+    uint textureLevel;
+    uint textureLayer;
+
+    bool reverseTextureRowOrder;
+};
+# 120 "./copy_buffer.metal"
+template <typename T>
+static inline void textureWrite(ushort3 gIndices,
+                                constant CopyPixelParams &options,
+                                vec<T, 4> color,
+                                texture2d<T, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    uint3 writeIndices = options.textureOffset + uint3(gIndices);
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            dstTexture2d.write(color, writeIndices.xy);
+            break;
+        case kTextureType2DArray:
+            dstTexture2dArray.write(color, writeIndices.xy, writeIndices.z);
+            break;
+        case kTextureType3D:
+            dstTexture3d.write(color, writeIndices);
+            break;
+        case kTextureTypeCube:
+            dstTextureCube.write(color, writeIndices.xy, writeIndices.z);
+            break;
+    }
+}
+
+
+template <typename T>
+static inline vec<T, 4> textureRead(ushort2 gIndices,
+                                    constant WritePixelParams &options,
+                                    texture2d<T, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<T, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<T, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<T, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<T, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]])
+{
+    vec<T, 4> color;
+    uint2 coords = uint2(gIndices);
+    if (options.reverseTextureRowOrder)
+    {
+        coords.y = options.copySize.y - 1 - gIndices.y;
+    }
+    coords += options.textureOffset;
+    switch (kCopyTextureType)
+    {
+        case kTextureType2D:
+            color = srcTexture2d.read(coords.xy, options.textureLevel);
+            break;
+        case kTextureType2DArray:
+            color = srcTexture2dArray.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+        case kTextureType2DMultisample:
+            color = resolveTextureMS(srcTexture2dMS, coords.xy);
+            break;
+        case kTextureType3D:
+            color = srcTexture3d.read(uint3(coords, options.textureLayer), options.textureLevel);
+            break;
+        case kTextureTypeCube:
+            color = srcTextureCube.read(coords.xy, options.textureLayer, options.textureLevel);
+            break;
+    }
+    return color;
+}
+# 215 "./copy_buffer.metal"
+static inline float4 readR5G6B5_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<6>(getShiftedData<6, 5>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 0>(src));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR5G6B5_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<6, 5>(floatToNormalized<6, ushort>(color.g)) |
+                 shiftData<5, 0>(floatToNormalized<5, ushort>(color.b));
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR4G4B4A4_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<4>(getShiftedData<4, 12>(src));
+    color.g = normalizedToFloat<4>(getShiftedData<4, 8>(src));
+    color.b = normalizedToFloat<4>(getShiftedData<4, 4>(src));
+    color.a = normalizedToFloat<4>(getShiftedData<4, 0>(src));
+    return color;
+}
+static inline void writeR4G4B4A4_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<4, 12>(floatToNormalized<4, ushort>(color.r)) |
+                 shiftData<4, 8>(floatToNormalized<4, ushort>(color.g)) |
+                 shiftData<4, 4>(floatToNormalized<4, ushort>(color.b)) |
+                 shiftData<4, 0>(floatToNormalized<4, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR5G5B5A1_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    ushort src = bytesToShort<ushort>(buffer, bufferOffset);
+
+    color.r = normalizedToFloat<5>(getShiftedData<5, 11>(src));
+    color.g = normalizedToFloat<5>(getShiftedData<5, 6>(src));
+    color.b = normalizedToFloat<5>(getShiftedData<5, 1>(src));
+    color.a = normalizedToFloat<1>(getShiftedData<1, 0>(src));
+    return color;
+}
+static inline void writeR5G5B5A1_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    ushort dst = shiftData<5, 11>(floatToNormalized<5, ushort>(color.r)) |
+                 shiftData<5, 6>(floatToNormalized<5, ushort>(color.g)) |
+                 shiftData<5, 1>(floatToNormalized<5, ushort>(color.b)) |
+                 shiftData<1, 0>(floatToNormalized<1, ushort>(color.a));
+    ;
+
+    shortToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline int4 readR10G10B10A2_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    int src = bytesToInt<int>(buffer, bufferOffset);
+
+    constexpr int3 rgbSignMask(0x200);
+    constexpr int3 negativeMask(0xfffffc00);
+    constexpr int alphaSignMask = 0x2;
+    constexpr int alphaNegMask = 0xfffffffc;
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+
+    int3 isRgbNegative = (color.rgb & rgbSignMask) >> 9;
+    color.rgb = (isRgbNegative * negativeMask) | color.rgb;
+
+    color.a = getShiftedData<2, 30>(src);
+    int isAlphaNegative = color.a & alphaSignMask >> 1;
+    color.a = (isAlphaNegative * alphaNegMask) | color.a;
+    return color;
+}
+
+static inline uint4 readR10G10B10A2_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color.r = getShiftedData<10, 0>(src);
+    color.g = getShiftedData<10, 10>(src);
+    color.b = getShiftedData<10, 20>(src);
+    color.a = getShiftedData<2, 30>(src);
+    return color;
+}
+
+
+static inline float4 readR8G8B8A8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    if (isSRGB)
+    {
+        color = unpack_unorm4x8_srgb_to_float(src);
+    }
+    else
+    {
+        color = unpack_unorm4x8_to_float(src);
+    }
+    return color;
+}
+static inline void writeR8G8B8A8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+static inline float4 readR8G8B8(uint bufferOffset, constant uchar *buffer, bool isSRGB)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    if (isSRGB)
+    {
+        color = sRGBtoLinear(color);
+    }
+    return color;
+}
+static inline void writeR8G8B8(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer, bool isSRGB)
+{
+    color.a = 1.0;
+    uint dst;
+
+    if (isSRGB)
+    {
+        dst = pack_float_to_srgb_unorm4x8(color);
+    }
+    else
+    {
+        dst = pack_float_to_unorm4x8(color);
+    }
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    uint src = bytesToInt<uint>(buffer, bufferOffset);
+
+    color = unpack_snorm4x8_to_float(src);
+
+    return color;
+}
+static inline void writeR8G8B8A8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    intToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = normalizedToFloat<7, char>(buffer[bufferOffset + 2]);
+    color.a = 1.0;
+
+    return color;
+}
+static inline void writeR8G8B8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    uint dst = pack_float_to_snorm4x8(color);
+
+    int24bitToBytes(dst, bufferOffset, buffer);
+}
+
+
+static inline float4 readR8G8B8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readB8G8R8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, false).bgra;
+}
+static inline void writeB8G8R8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readB8G8R8A8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8A8(bufferOffset, buffer, true).bgra;
+}
+static inline void writeB8G8R8A8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    color.rgba = color.bgra;
+    return writeR8G8B8A8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readR8G8B8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, false);
+}
+static inline void writeR8G8B8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, false);
+}
+
+static inline float4 readR8G8B8_UNORM_SRGB(uint bufferOffset, constant uchar *buffer)
+{
+    return readR8G8B8(bufferOffset, buffer, true);
+}
+static inline void writeR8G8B8_UNORM_SRGB(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    return writeR8G8B8(gIndices, options, bufferOffset, color, buffer, true);
+}
+
+
+static inline float4 readL8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+
+static inline void writeA8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readL8A8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = float3(normalizedToFloat<uchar>(buffer[bufferOffset]));
+    color.a = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    return color;
+}
+static inline void writeL8A8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.a);
+}
+
+
+static inline float4 readR8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+}
+
+static inline float4 readR8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+}
+
+
+static inline int4 readR8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline uint4 readR8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+}
+
+
+static inline float4 readR8G8_UNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<uchar>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_UNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = floatToNormalized<uchar>(color.r);
+    buffer[bufferOffset + 1] = floatToNormalized<uchar>(color.g);
+}
+
+static inline float4 readR8G8_SNORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<7, char>(buffer[bufferOffset]);
+    color.g = normalizedToFloat<7, char>(buffer[bufferOffset + 1]);
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR8G8_SNORM(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = as_type<uchar>(floatToNormalized<7, char>(color.r));
+    buffer[bufferOffset + 1] = as_type<uchar>(floatToNormalized<7, char>(color.g));
+}
+
+
+static inline int4 readR8G8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline uint4 readR8G8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR8G8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+}
+
+
+static inline int4 readR8G8B8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR8G8B8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = 1;
+    return color;
+}
+
+
+static inline int4 readR8G8B8A8_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = as_type<char>(buffer[bufferOffset]);
+    color.g = as_type<char>(buffer[bufferOffset + 1]);
+    color.b = as_type<char>(buffer[bufferOffset + 2]);
+    color.a = as_type<char>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline uint4 readR8G8B8A8_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = as_type<uchar>(buffer[bufferOffset]);
+    color.g = as_type<uchar>(buffer[bufferOffset + 1]);
+    color.b = as_type<uchar>(buffer[bufferOffset + 2]);
+    color.a = as_type<uchar>(buffer[bufferOffset + 3]);
+    return color;
+}
+static inline void writeR8G8B8A8_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    buffer[bufferOffset] = static_cast<uchar>(color.r);
+    buffer[bufferOffset + 1] = static_cast<uchar>(color.g);
+    buffer[bufferOffset + 2] = static_cast<uchar>(color.b);
+    buffer[bufferOffset + 3] = static_cast<uchar>(color.a);
+}
+
+
+static inline float4 readR16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+template <typename ShortType>
+static inline float4 readR16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+}
+
+
+static inline uint4 readR16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+}
+
+
+static inline float4 readA16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+}
+
+
+static inline float4 readL16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    return color;
+}
+static inline void writeL16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR16G16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline uint4 readR16G16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR16G16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+}
+
+
+static inline float4 readR16G16B16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+static inline int4 readR16G16B16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline uint4 readR16G16B16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR16G16B16A16_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset));
+    color.g = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 2));
+    color.b = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 4));
+    color.a = as_type<half>(bytesToShort<ushort>(buffer, bufferOffset + 6));
+    return color;
+}
+static inline void writeR16G16B16A16_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    shortToBytes(as_type<ushort>(static_cast<half>(color.r)), bufferOffset, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.g)), bufferOffset + 2, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.b)), bufferOffset + 4, buffer);
+    shortToBytes(as_type<ushort>(static_cast<half>(color.a)), bufferOffset + 6, buffer);
+}
+
+
+template <typename ShortType>
+static inline float4 readR16G16B16A16_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 2));
+    color.b = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 4));
+    color.a = normalizedToFloat<ShortType>(bytesToShort<ShortType>(buffer, bufferOffset + 6));
+    return color;
+}
+
+
+
+
+static inline int4 readR16G16B16A16_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToShort<short>(buffer, bufferOffset);
+    color.g = bytesToShort<short>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<short>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<short>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<short>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<short>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<short>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<short>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline uint4 readR16G16B16A16_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToShort<ushort>(buffer, bufferOffset);
+    color.g = bytesToShort<ushort>(buffer, bufferOffset + 2);
+    color.b = bytesToShort<ushort>(buffer, bufferOffset + 4);
+    color.a = bytesToShort<ushort>(buffer, bufferOffset + 6);
+    return color;
+}
+static inline void writeR16G16B16A16_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    shortToBytes(static_cast<ushort>(color.r), bufferOffset, buffer);
+    shortToBytes(static_cast<ushort>(color.g), bufferOffset + 2, buffer);
+    shortToBytes(static_cast<ushort>(color.b), bufferOffset + 4, buffer);
+    shortToBytes(static_cast<ushort>(color.a), bufferOffset + 6, buffer);
+}
+
+
+static inline float4 readR32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline float4 readA32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.rgb = 0.0;
+    return color;
+}
+static inline void writeA32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.a), bufferOffset, buffer);
+}
+
+
+static inline float4 readL32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = 1.0;
+    return color;
+}
+static inline void writeL32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+}
+
+
+static inline int4 readR32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readR32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+}
+
+
+static inline float4 readL32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.rgb = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    return color;
+}
+static inline void writeL32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+static inline void writeR32G32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = 0.0;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = 0;
+    color.a = 1;
+    return color;
+}
+static inline void writeR32G32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+}
+
+
+static inline float4 readR32G32B32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = 1.0;
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = 1.0;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = 1;
+    return color;
+}
+
+
+static inline float4 readR32G32B32A32_FLOAT(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = as_type<float>(bytesToInt<uint>(buffer, bufferOffset));
+    color.g = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 4));
+    color.b = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 8));
+    color.a = as_type<float>(bytesToInt<uint>(buffer, bufferOffset + 12));
+    return color;
+}
+static inline void writeR32G32B32A32_FLOAT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<float, 4> color, device uchar *buffer)
+{
+    intToBytes(as_type<uint>(color.r), bufferOffset, buffer);
+    intToBytes(as_type<uint>(color.g), bufferOffset + 4, buffer);
+    intToBytes(as_type<uint>(color.b), bufferOffset + 8, buffer);
+    intToBytes(as_type<uint>(color.a), bufferOffset + 12, buffer);
+}
+
+
+template <typename IntType>
+static inline float4 readR32G32B32A32_NORM(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    color.r = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset));
+    color.g = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 4));
+    color.b = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 8));
+    color.a = normalizedToFloat<IntType>(bytesToInt<IntType>(buffer, bufferOffset + 12));
+    return color;
+}
+
+
+
+
+static inline int4 readR32G32B32A32_SINT(uint bufferOffset, constant uchar *buffer)
+{
+    int4 color;
+    color.r = bytesToInt<int>(buffer, bufferOffset);
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_SINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<int, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+
+static inline float4 readR32G32B32A32_FIXED(uint bufferOffset, constant uchar *buffer)
+{
+    float4 color;
+    constexpr float kDivisor = 1.0f / (1 << 16);
+    color.r = bytesToInt<int>(buffer, bufferOffset) * kDivisor;
+    color.g = bytesToInt<int>(buffer, bufferOffset + 4) * kDivisor;
+    color.b = bytesToInt<int>(buffer, bufferOffset + 8) * kDivisor;
+    color.a = bytesToInt<int>(buffer, bufferOffset + 12) * kDivisor;
+    return color;
+}
+
+
+static inline uint4 readR32G32B32A32_UINT(uint bufferOffset, constant uchar *buffer)
+{
+    uint4 color;
+    color.r = bytesToInt<uint>(buffer, bufferOffset);
+    color.g = bytesToInt<uint>(buffer, bufferOffset + 4);
+    color.b = bytesToInt<uint>(buffer, bufferOffset + 8);
+    color.a = bytesToInt<uint>(buffer, bufferOffset + 12);
+    return color;
+}
+static inline void writeR32G32B32A32_UINT(ushort2 gIndices, constant WritePixelParams &options, uint bufferOffset, vec<uint, 4> color, device uchar *buffer)
+{
+    intToBytes(color.r, bufferOffset, buffer);
+    intToBytes(color.g, bufferOffset + 4, buffer);
+    intToBytes(color.b, bufferOffset + 8, buffer);
+    intToBytes(color.a, bufferOffset + 12, buffer);
+}
+# 1292 "./copy_buffer.metal"
+static inline int4 readR8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8_SINT(bufferOffset, buffer); } static inline uint4 readR8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8_UINT(bufferOffset, buffer); } static inline int4 readR8G8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8_UINT(bufferOffset, buffer); } static inline int4 readR8G8B8A8_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_SINT(bufferOffset, buffer); } static inline uint4 readR8G8B8A8_USCALED(uint bufferOffset, constant uchar *buffer) { return readR8G8B8A8_UINT(bufferOffset, buffer); }
+static inline int4 readR16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16_SINT(bufferOffset, buffer); } static inline uint4 readR16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16_UINT(bufferOffset, buffer); } static inline int4 readR16G16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16_UINT(bufferOffset, buffer); } static inline int4 readR16G16B16A16_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_SINT(bufferOffset, buffer); } static inline uint4 readR16G16B16A16_USCALED(uint bufferOffset, constant uchar *buffer) { return readR16G16B16A16_UINT(bufferOffset, buffer); }
+static inline int4 readR32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32_SINT(bufferOffset, buffer); } static inline uint4 readR32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32_UINT(bufferOffset, buffer); } static inline int4 readR32G32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32_UINT(bufferOffset, buffer); } static inline int4 readR32G32B32A32_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_SINT(bufferOffset, buffer); } static inline uint4 readR32G32B32A32_USCALED(uint bufferOffset, constant uchar *buffer) { return readR32G32B32A32_UINT(bufferOffset, buffer); }
+
+static inline int4 readR10G10B10A2_SSCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_SINT(bufferOffset, buffer); } static inline uint4 readR10G10B10A2_USCALED(uint bufferOffset, constant uchar *buffer) { return readR10G10B10A2_UINT(bufferOffset, buffer); }
+
+
+kernel void readFromBufferToFloatTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<float, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1336 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = readR5G6B5_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM: { auto color = readR8G8B8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = readR8G8B8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SNORM: { auto color = readR8G8B8A8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM: { auto color = readB8G8R8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = readB8G8R8A8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM: { auto color = readR8G8B8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = readR8G8B8_UNORM_SRGB(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SNORM: { auto color = readR8G8B8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8_UNORM: { auto color = readL8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L8A8_UNORM: { auto color = readL8A8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R5G5B5A1_UNORM: { auto color = readR5G5B5A1_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R4G4B4A4_UNORM: { auto color = readR4G4B4A4_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_UNORM: { auto color = readR8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8_SNORM: { auto color = readR8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UNORM: { auto color = readR8G8_UNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SNORM: { auto color = readR8G8_SNORM(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_FLOAT: { auto color = readR16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A16_FLOAT: { auto color = readA16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16_FLOAT: { auto color = readL16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L16A16_FLOAT: { auto color = readL16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_FLOAT: { auto color = readR16G16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_FLOAT: { auto color = readR16G16B16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = readR16G16B16A16_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_FLOAT: { auto color = readR32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::A32_FLOAT: { auto color = readA32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32_FLOAT: { auto color = readL32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::L32A32_FLOAT: { auto color = readL32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_FLOAT: { auto color = readR32G32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_FLOAT: { auto color = readR32G32B32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = readR32G32B32A32_FLOAT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<int, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1364 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = readR8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_SINT: { auto color = readR8G8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_SINT: { auto color = readR8G8B8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_SINT: { auto color = readR8G8B8A8_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_SINT: { auto color = readR16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_SINT: { auto color = readR16G16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_SINT: { auto color = readR16G16B16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_SINT: { auto color = readR16G16B16A16_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_SINT: { auto color = readR32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_SINT: { auto color = readR32G32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_SINT: { auto color = readR32G32B32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_SINT: { auto color = readR32G32B32A32_SINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+kernel void readFromBufferToUIntTexture(ushort3 gIndices [[thread_position_in_grid]], constant CopyPixelParams &options[[buffer(0)]], constant uchar *buffer [[buffer(1)]], texture2d<uint, access::write> dstTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::write> dstTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::write> dstTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::write> dstTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y || gIndices.z >= options.copySize.z) { return; }
+# 1392 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.z * options.bufferDepthPitch + gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = readR8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8_UINT: { auto color = readR8G8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8_UINT: { auto color = readR8G8B8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R8G8B8A8_UINT: { auto color = readR8G8B8A8_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16_UINT: { auto color = readR16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16_UINT: { auto color = readR16G16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16_UINT: { auto color = readR16G16B16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R16G16B16A16_UINT: { auto color = readR16G16B16A16_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32_UINT: { auto color = readR32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32_UINT: { auto color = readR32G32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32_UINT: { auto color = readR32G32B32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break; case FormatID::R32G32B32A32_UINT: { auto color = readR32G32B32A32_UINT(bufferOffset, buffer); textureWrite(gIndices, options, color, dstTexture2d, dstTexture2dArray, dstTexture3d, dstTextureCube); } break;
+    }
+
+
+}
+
+
+kernel void writeFromFloatTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<float, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<float, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<float, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<float, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<float, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1439 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R5G6B5_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G6B5_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::B8G8R8A8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeB8G8R8A8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_UNORM_SRGB: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_UNORM_SRGB(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L8A8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL8A8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R5G5B5A1_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR5G5B5A1_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R4G4B4A4_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR4G4B4A4_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SNORM: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SNORM(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeA32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::L32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeL32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_FLOAT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<int, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<int, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<int, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<int, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<int, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1464 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_SINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_SINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_SINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+kernel void writeFromUIntTextureToBuffer(ushort2 gIndices [[thread_position_in_grid]], constant WritePixelParams &options[[buffer(0)]], texture2d<uint, access::read> srcTexture2d [[texture(0), function_constant(kCopyTextureType2D)]], texture2d_array<uint, access::read> srcTexture2dArray [[texture(0), function_constant(kCopyTextureType2DArray)]], texture3d<uint, access::read> srcTexture3d [[texture(0), function_constant(kCopyTextureType3D)]], texturecube<uint, access::read> srcTextureCube [[texture(0), function_constant(kCopyTextureTypeCube)]], texture2d_ms<uint, access::read> srcTexture2dMS [[texture(0), function_constant(kCopyTextureType2DMS)]], device uchar *buffer [[buffer(1)]])
+{
+    if (gIndices.x >= options.copySize.x || gIndices.y >= options.copySize.y) { return; }
+# 1489 "./copy_buffer.metal"
+    uint bufferOffset = options.bufferStartOffset + (gIndices.y * options.bufferRowPitch + gIndices.x * options.pixelSize);
+
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R8G8B8A8_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR8G8B8A8_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R16G16B16A16_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR16G16B16A16_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32_UINT(gIndices, options, bufferOffset, color, buffer); } break; case FormatID::R32G32B32A32_UINT: { auto color = textureRead(gIndices, options, srcTexture2d, srcTexture2dArray, srcTexture3d, srcTextureCube, srcTexture2dMS); writeR32G32B32A32_UINT(gIndices, options, bufferOffset, color, buffer); } break;
+    }
+
+
+}
+
+
+struct CopyVertexParams
+{
+    uint srcBufferStartOffset;
+    uint srcStride;
+    uint srcComponentBytes;
+    uint srcComponents;
+
+
+
+    uchar4 srcDefaultAlphaData;
+
+    uint dstBufferStartOffset;
+    uint dstStride;
+    uint dstComponents;
+
+    uint vertexCount;
+};
+# 1539 "./copy_buffer.metal"
+template <typename IntType>
+static inline void writeFloatVertex(constant CopyVertexParams &options,
+                                    uint idx,
+                                    vec<IntType, 4> data,
+                                    device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(static_cast<float>(data[component]), dstOffset, dst);
+    }
+}
+
+template <>
+inline void writeFloatVertex(constant CopyVertexParams &options,
+                             uint idx,
+                             vec<float, 4> data,
+                             device uchar *dst)
+{
+    uint dstOffset = idx * options.dstStride + options.dstBufferStartOffset;
+
+    for (uint component = 0; component < options.dstComponents; ++component, dstOffset += 4)
+    {
+        floatToBytes(data[component], dstOffset, dst);
+    }
+}
+
+
+static inline void convertToFloatVertexFormat(uint index,
+                                              constant CopyVertexParams &options,
+                                              constant uchar *srcBuffer,
+                                              device uchar *dstBuffer)
+{
+# 1585 "./copy_buffer.metal"
+    uint bufferOffset = options.srcBufferStartOffset + options.srcStride * index;
+# 1594 "./copy_buffer.metal"
+    switch (kCopyFormatType)
+    {
+        case FormatID::R8_UNORM: { auto data = readR8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SNORM: { auto data = readR8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_UINT: { auto data = readR8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SINT: { auto data = readR8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_USCALED: { auto data = readR8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8_SSCALED: { auto data = readR8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UNORM: { auto data = readR8G8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SNORM: { auto data = readR8G8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_UINT: { auto data = readR8G8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SINT: { auto data = readR8G8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_USCALED: { auto data = readR8G8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8_SSCALED: { auto data = readR8G8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UNORM: { auto data = readR8G8B8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SNORM: { auto data = readR8G8B8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_UINT: { auto data = readR8G8B8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SINT: { auto data = readR8G8B8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_USCALED: { auto data = readR8G8B8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8_SSCALED: { auto data = readR8G8B8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UNORM: { auto data = readR8G8B8A8_UNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SNORM: { auto data = readR8G8B8A8_SNORM(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_UINT: { auto data = readR8G8B8A8_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SINT: { auto data = readR8G8B8A8_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_USCALED: { auto data = readR8G8B8A8_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R8G8B8A8_SSCALED: { auto data = readR8G8B8A8_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UNORM: { auto data = readR16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SNORM: { auto data = readR16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_UINT: { auto data = readR16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SINT: { auto data = readR16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_USCALED: { auto data = readR16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_SSCALED: { auto data = readR16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UNORM: { auto data = readR16G16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SNORM: { auto data = readR16G16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_UINT: { auto data = readR16G16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SINT: { auto data = readR16G16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_USCALED: { auto data = readR16G16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_SSCALED: { auto data = readR16G16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UNORM: { auto data = readR16G16B16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SNORM: { auto data = readR16G16B16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_UINT: { auto data = readR16G16B16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SINT: { auto data = readR16G16B16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_USCALED: { auto data = readR16G16B16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_SSCALED: { auto data = readR16G16B16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UNORM: { auto data = readR16G16B16A16_NORM<ushort>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SNORM: { auto data = readR16G16B16A16_NORM<short>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_UINT: { auto data = readR16G16B16A16_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SINT: { auto data = readR16G16B16A16_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_USCALED: { auto data = readR16G16B16A16_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_SSCALED: { auto data = readR16G16B16A16_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UNORM: { auto data = readR32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SNORM: { auto data = readR32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_UINT: { auto data = readR32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SINT: { auto data = readR32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_USCALED: { auto data = readR32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_SSCALED: { auto data = readR32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UNORM: { auto data = readR32G32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SNORM: { auto data = readR32G32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_UINT: { auto data = readR32G32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SINT: { auto data = readR32G32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_USCALED: { auto data = readR32G32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_SSCALED: { auto data = readR32G32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UNORM: { auto data = readR32G32B32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SNORM: { auto data = readR32G32B32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_UINT: { auto data = readR32G32B32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SINT: { auto data = readR32G32B32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_USCALED: { auto data = readR32G32B32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_SSCALED: { auto data = readR32G32B32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UNORM: { auto data = readR32G32B32A32_NORM<uint>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SNORM: { auto data = readR32G32B32A32_NORM<int>(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_UINT: { auto data = readR32G32B32A32_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SINT: { auto data = readR32G32B32A32_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_USCALED: { auto data = readR32G32B32A32_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_SSCALED: { auto data = readR32G32B32A32_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16_FLOAT: { auto data = readR16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16_FLOAT: { auto data = readR16G16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16_FLOAT: { auto data = readR16G16B16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R16G16B16A16_FLOAT: { auto data = readR16G16B16A16_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FLOAT: { auto data = readR32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FLOAT: { auto data = readR32G32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FLOAT: { auto data = readR32G32B32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FLOAT: { auto data = readR32G32B32A32_FLOAT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32_FIXED: { auto data = readR32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32_FIXED: { auto data = readR32G32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32_FIXED: { auto data = readR32G32B32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R32G32B32A32_FIXED: { auto data = readR32G32B32A32_FIXED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SINT: { auto data = readR10G10B10A2_SINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_UINT: { auto data = readR10G10B10A2_UINT(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_SSCALED: { auto data = readR10G10B10A2_SSCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break; case FormatID::R10G10B10A2_USCALED: { auto data = readR10G10B10A2_USCALED(bufferOffset, srcBuffer); writeFloatVertex(options, index, data, dstBuffer); } break;
+    }
+
+
+}
+
+
+kernel void convertToFloatVertexFormatCS(uint index [[thread_position_in_grid]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void convertToFloatVertexFormatVS(uint index [[vertex_id]],
+                                         constant CopyVertexParams &options [[buffer(0)]],
+                                         constant uchar *srcBuffer [[buffer(1)]],
+                                         device uchar *dstBuffer [[buffer(2)]])
+{
+    convertToFloatVertexFormat(index, options, srcBuffer, dstBuffer);
+}
+
+
+static inline void expandVertexFormatComponents(uint index,
+                                                constant CopyVertexParams &options,
+                                                constant uchar *srcBuffer,
+                                                device uchar *dstBuffer)
+{
+    uint srcOffset = options.srcBufferStartOffset + options.srcStride * index;
+    uint dstOffset = options.dstBufferStartOffset + options.dstStride * index;
+
+    uint dstComponentsBeforeAlpha = min(options.dstComponents, 3u);
+    uint component;
+    for (component = 0; component < options.srcComponents; ++component,
+        srcOffset += options.srcComponentBytes, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = srcBuffer[srcOffset + byte];
+        }
+    }
+
+    for (; component < dstComponentsBeforeAlpha;
+         ++component, dstOffset += options.srcComponentBytes)
+    {
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = 0;
+        }
+    }
+
+    if (component < options.dstComponents)
+    {
+
+        for (uint byte = 0; byte < options.srcComponentBytes; ++byte)
+        {
+            dstBuffer[dstOffset + byte] = options.srcDefaultAlphaData[byte];
+        }
+    }
+}
+
+
+kernel void expandVertexFormatComponentsCS(uint index [[thread_position_in_grid]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    if (index >= options.vertexCount) { return; };
+
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+
+
+vertex void expandVertexFormatComponentsVS(uint index [[vertex_id]],
+                                           constant CopyVertexParams &options [[buffer(0)]],
+                                           constant uchar *srcBuffer [[buffer(1)]],
+                                           device uchar *dstBuffer [[buffer(2)]])
+{
+    expandVertexFormatComponents(index, options, srcBuffer, dstBuffer);
+}
+# 6 "temp_master_source.metal" 2
+# 1 "./visibility.metal" 1
+
+
+
+
+
+
+
+
+constant bool kCombineWithExistingResult [[function_constant(1000)]];
+
+
+
+struct CombineVisibilityResultOptions
+{
+
+    uint startOffset;
+
+    uint numOffsets;
+};
+
+kernel void combineVisibilityResult(uint idx [[thread_position_in_grid]],
+                                    constant CombineVisibilityResultOptions &options [[buffer(0)]],
+                                    constant ushort4 *renderpassVisibilityResult [[buffer(1)]],
+                                    device ushort4 *finalResults [[buffer(2)]])
+{
+    if (idx > 0)
+    {
+
+
+
+        return;
+    }
+    ushort4 finalResult16x4;
+
+    if (kCombineWithExistingResult)
+    {
+        finalResult16x4 = finalResults[0];
+    }
+    else
+    {
+        finalResult16x4 = ushort4(0, 0, 0, 0);
+    }
+
+    for (uint i = 0; i < options.numOffsets; ++i)
+    {
+        uint offset = options.startOffset + i;
+        ushort4 renderpassResult = renderpassVisibilityResult[offset];
+
+
+        finalResult16x4 = finalResult16x4 | renderpassResult;
+    }
+    finalResults[0] = finalResult16x4;
+}
+# 7 "temp_master_source.metal" 2
+# 1 "./rewrite_indices.metal" 1
+# 11 "./rewrite_indices.metal"
+# 1 "./rewrite_indices_shared.h" 1
+# 12 "./rewrite_indices.metal" 2
+using namespace metal;
+
+constant uint fixIndexBufferKey [[ function_constant(2000) ]];
+constant bool indexBufferIsUint16 = (((fixIndexBufferKey >> 0U) & 0x03U) == 2U);
+constant bool indexBufferIsUint32 = (((fixIndexBufferKey >> 0U) & 0x03U) == 3U);
+constant bool outIndexBufferIsUint16 = (((fixIndexBufferKey >> 2U) & 0x03U) == 2U);
+constant bool outIndexBufferIsUint32 = (((fixIndexBufferKey >> 2U) & 0x03U) == 3U);
+constant bool doPrimRestart = (fixIndexBufferKey & 0x00100U);
+constant uint fixIndexBufferMode = (fixIndexBufferKey >> 4U) & 0x0FU;
+
+
+static inline uint readIdx(
+                           const device ushort *indexBufferUint16,
+                           const device uint *indexBufferUint32,
+                           const uint restartIndex,
+                           const uint indexCount,
+                           uint idx,
+                           thread bool &foundRestart,
+                           thread uint &indexThatRestartedFirst
+                           )
+{
+    uint inIndex = idx;
+    if(inIndex < indexCount)
+    {
+        if(indexBufferIsUint16)
+        {
+            inIndex = indexBufferUint16[inIndex];
+        }
+        else if(indexBufferIsUint32)
+        {
+            inIndex = indexBufferUint32[inIndex];
+        }
+    }
+    else
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    if(doPrimRestart && !foundRestart && inIndex == restartIndex)
+    {
+        foundRestart = true;
+        indexThatRestartedFirst = idx;
+    }
+    return inIndex;
+}
+
+static inline void outputPrimitive(
+                                   const device ushort *indexBufferUint16,
+                                   const device uint *indexBufferUint32,
+                                   device ushort *outIndexBufferUint16,
+                                   device uint *outIndexBufferUint32,
+                                   const uint restartIndex,
+                                   const uint indexCount,
+                                   thread uint &baseIndex,
+                                   uint onIndex,
+                                   thread uint &onOutIndex
+                                   )
+{
+    if(baseIndex > onIndex) return;
+    bool foundRestart = false;
+    uint indexThatRestartedFirst = 0;
+# 86 "./rewrite_indices.metal"
+    switch(fixIndexBufferMode)
+    {
+        case 0x00U:
+        {
+            auto tmpIndex = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex; } onOutIndex++; });
+        }
+        break;
+        case 0x01U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if((onIndex - baseIndex) & 1) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x03U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x04U:
+        {
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+            if(((onIndex - baseIndex) % 3) != 0) return;
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+            }
+        }
+        break;
+        case 0x05U:
+        {
+            uint isOdd = ((onIndex - baseIndex) & 1);
+            auto tmpIndex0 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 0 + isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex1 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 1 - isOdd, foundRestart, indexThatRestartedFirst);
+            auto tmpIndex2 = readIdx(indexBufferUint16, indexBufferUint32, restartIndex, indexCount, onIndex + 2, foundRestart, indexThatRestartedFirst);
+            if(foundRestart)
+            {
+                baseIndex = indexThatRestartedFirst + 1;
+                return;
+            }
+
+            if(fixIndexBufferKey & 0x00200U)
+            {
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+            }
+            else
+            {
+
+                if(isOdd)
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                }
+                else
+                {
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex0; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex0; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex1; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex1; } onOutIndex++; });
+                    ({ if(outIndexBufferIsUint16) { outIndexBufferUint16[(onOutIndex)] = tmpIndex2; } if(outIndexBufferIsUint32) { outIndexBufferUint32[(onOutIndex)] = tmpIndex2; } onOutIndex++; });
+                }
+            }
+
+            assert(onOutIndex <= (onIndex + 1) * 3);
+            assert(onOutIndex <= (indexCount - 2) * 3);
+        }
+        break;
+
+    }
+
+
+}
+
+kernel void fixIndexBuffer(
+                           const device ushort *indexBufferUint16 [[ buffer(0), function_constant(indexBufferIsUint16) ]],
+                           const device uint *indexBufferUint32 [[ buffer(0), function_constant(indexBufferIsUint32) ]],
+                           device ushort *outIndexBufferUint16 [[ buffer(1), function_constant(outIndexBufferIsUint16) ]],
+                           device uint *outIndexBufferUint32 [[ buffer(1), function_constant(outIndexBufferIsUint32) ]],
+                           constant uint &indexCount [[ buffer(2) ]],
+                           constant uint &primCount [[ buffer(3) ]],
+                           uint prim [[thread_position_in_grid]])
+{
+    constexpr uint restartIndex = 0xFFFFFFFF;
+    uint baseIndex = 0;
+    uint onIndex = onIndex;
+    uint onOutIndex = onOutIndex;
+    if(prim < primCount)
+    {
+        switch(fixIndexBufferMode)
+        {
+            case 0x00U:
+                onIndex = prim;
+                onOutIndex = prim;
+                break;
+            case 0x01U:
+                onIndex = prim * 2 + 0;
+                onOutIndex = prim * 2 + 0;
+                break;
+            case 0x03U:
+                onIndex = prim;
+                onOutIndex = prim * 2 + 0;
+                break;
+            case 0x04U:
+                onIndex = prim * 3 + 0;
+                onOutIndex = prim * 3 + 0;
+                break;
+            case 0x05U:
+                onIndex = prim;
+                onOutIndex = prim * 3 + 0;
+                break;
+        }
+        outputPrimitive(indexBufferUint16, indexBufferUint32, outIndexBufferUint16, outIndexBufferUint32, restartIndex, indexCount, baseIndex, onIndex, onOutIndex);
+    }
+}
+# 8 "temp_master_source.metal" 2
+
diff --git a/src/libANGLE/validationES.h b/src/libANGLE/validationES.h
index 86a82b1..32bcd73 100644
--- a/src/libANGLE/validationES.h
+++ b/src/libANGLE/validationES.h
@@ -1007,6 +1007,17 @@ ANGLE_INLINE bool ValidateDrawArraysCommon(const Context *context,
         return ValidateDrawBase(context, entryPoint, mode);
     }
 
+    if (primcount <= 0)
+    {
+        if (primcount < 0)
+        {
+            context->validationError(entryPoint, GL_INVALID_VALUE, err::kNegativeCount);
+            return false;
+        }
+        // Early exit.
+        return ValidateDrawBase(context, entryPoint, mode);
+    }
+
     if (!ValidateDrawBase(context, entryPoint, mode))
     {
         return false;
diff --git a/src/tests/angle_unittests.gni b/src/tests/angle_unittests.gni
index 61345f8..dd70b9f 100644
--- a/src/tests/angle_unittests.gni
+++ b/src/tests/angle_unittests.gni
@@ -166,6 +166,8 @@ if (is_android) {
       [ "compiler_tests/ImmutableString_test_autogen.cpp" ]
 }
 
+angle_unittests_msl_sources = [ "../tests/compiler_tests/MSLOutput_test.cpp" ]
+
 if (!is_android && !is_fuchsia) {
   angle_unittests_sources += [ "test_utils/runner/TestSuite_unittest.cpp" ]
 }
diff --git a/src/tests/deqp_support/deqp_egl_test_expectations.txt b/src/tests/deqp_support/deqp_egl_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_egl_test_expectations.txt
rename to src/tests/deqp_support/deqp_egl_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles2_test_expectations.txt b/src/tests/deqp_support/deqp_gles2_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles2_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles2_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles31_test_expectations.txt b/src/tests/deqp_support/deqp_gles31_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles31_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles31_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles31_rotate_test_expectations.txt b/src/tests/deqp_support/deqp_gles31_rotate_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles31_rotate_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles31_rotate_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles3_test_expectations.txt b/src/tests/deqp_support/deqp_gles3_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles3_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles3_TestExpectations
diff --git a/src/tests/deqp_support/deqp_gles3_rotate_test_expectations.txt b/src/tests/deqp_support/deqp_gles3_rotate_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_gles3_rotate_test_expectations.txt
rename to src/tests/deqp_support/deqp_gles3_rotate_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles2_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles2_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles2_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles2_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles31_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles31_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles31_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles31_TestExpectations
diff --git a/src/tests/deqp_support/deqp_khr_gles3_test_expectations.txt b/src/tests/deqp_support/deqp_khr_gles3_TestExpectations
similarity index 100%
rename from src/tests/deqp_support/deqp_khr_gles3_test_expectations.txt
rename to src/tests/deqp_support/deqp_khr_gles3_TestExpectations
